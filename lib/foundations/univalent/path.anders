{- Path: https://anders.groupoid.space/foundations/univalent/path
   - Path Equality;
   - Computational properties;
   - Interval and De Morgan laws;
   - Generalized Transport;
   - Strict equality on partial and interval pretypes;
   - Cubical subtypes;
   - Generalized Homogeneous Composition;

   HoTT 1.12 Identity types
   HoTT 1.12.1 Path induction
   HoTT 2.1 Types are higher groupoids
   HoTT 2.11 Identity type
   HoTT 2.2 Functions are functors
   HoTT 3.11 Contractibility
   HoTT 5.8 Identity types and identity systems
   HoTT 6.2 Induction principles and dependent paths.

   Copyright (c) Groupoid Infinity, 2014-2023. -}

module path where
import lib/foundations/mltt/proto

--- Path Space

def Path (A : U) (x y : A) : U := PathP (<_> A) x y
def idp (A : U) (x : A) : Path A x x := <_> x
def singl (A: U) (a: A): U := Î£ (x: A), Path A a x
def eta (A: U) (a: A): singl A a := (a, idp A a)
def sym (A: U) (a b : A) (p : Path A a b) : Path A b a := <i> p @ -i
def contr (A : U) (a b : A) (p : Path A a b) : Path (singl A a) (eta A a) (b, p) := <i> (p @ i, <j> p @ i /\ j)
def isContr (A: U) : U := Î£ (x: A), Î  (y: A), Path A x y
def isContrSingl (A : U) (a : A) : isContr (singl A a) := ((a,idp A a),(\ (z:singl A a), contr A a z.1 z.2))
def cong (A B : U) (f : A â†’ B) (a b : A) (p : Path A a b) : Path B (f a) (f b) := <i> f (p @ i)
def ap (A: U) (a x: A) (B: A â†’ U) (f: A â†’ B a) (b: B a) (p: Path A a x): Path (B a) (f a) (f x) := <i> f (p @ i)
def mapOnPath (A: U) (B: A â†’ U) (a: A) (f: A â†’ B a) (b: B a) (x: A) (p: Path A a x): Path (B a) (f a) (f x) := <i> f (p @ i)
def inv (A: U) (a b: A) (p: Path A a b): Path A b a := <i> p @ -i
def Path-Î· (A : U) (x y : A) (p : Path A x y) : Path (Path A x y) p (<i> p @ i) := <_> p
def idp-left (A : U) (x y : A) (p : Path A x y) : Path (Path A x x) (<_> x) (<_> p @ 0) := <_ _> x
def idp-right (A : U) (x y : A) (p : Path A x y) : Path (Path A y y) (<_> y) (<_> p @ 1) := <_ _> y
def sym-sym-eq-idp (A : U) (x y : A) (p : Path A x y) : Path (Path A x y) p (sym A y x (sym A x y p)) := <_> p
def isProp (A : U) : U := Î  (a b : A), Path A a b
def isSet (A : U) : U := Î  (a b : A) (a0 b0 : Path A a b), Path (Path A a b) a0 b0
def isGroupoid (A : U) : U := Î  (a b : A) (x y : Path A a b) (i j : Path (Path A a b) x y), Path (Path (Path A a b) x y) i j
def SET : Uâ‚ := Î£ (X : U), isSet X
def Î©' : Uâ‚ := Î£ (A : U), isProp A
def section (A B : U) (f : A -> B) (g : B -> A) : U := Î  (b : B), Path B (f (g b)) b
def retract (A B : U) (f : A -> B) (g : B -> A) : U := Î  (a : A), Path A (g (f a)) a
def hmtpy (A : U) (x y : A) (p : Path A x y) : Path (Path A x x) (<_> x) (<i> p @ i /\ -i) := <j i> p @ j /\ i /\ -i
def plam (A : U) (f : I â†’ A) : Path A (f 0) (f 1) := <i> f i
def elim (A : U) (a b : A) (p : Path A a b) : I â†’ A := Î» (i : I), p @ i
def plam-elim (A : U) (f : I â†’ A) : Id (I â†’ A) (elim A (f 0) (f 1) (plam A f)) f := ref f
def elim-plam (A : U) (a b : A) (p : Path A a b) : Path (Path A a b) (plam A (elim A a b p)) p := <_> p

--- Path as [Left] Identity System, Computational Properties

def transport (A B: U) (p : PathP (<_> U) A B) (a: A): B := transp p 0 a
def trans_comp (A : U) (a : A) : Path A a (transport A A (<i> A) a) := <j> transp (<_> A) -j a
def subst (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b := transp (<i> P (p @ i)) 0 e
def D (A : U) : Uâ‚ â‰” Î  (x y : A), Path A x y â†’ U
def J (A: U) (x: A) (C: D A) (d: C x x (idp A x)) (y: A) (p: Path A x y): C x y p
 := subst (singl A x) (\ (z: singl A x), C x (z.1) (z.2)) (eta A x) (y, p) (contr A x y p) d
def subst-comp (A: U) (P: A â†’ U) (a: A) (e: P a): Path (P a) e (subst A P a a (idp A a) e) := trans_comp (P a) e
def J-Î² (A : U) (a : A) (C : D A) (d: C a a (idp A a)) : Path (C a a (idp A a)) d (J A a C d a (idp A a))
 := subst-comp (singl A a) (\ (z: singl A a), C a (z.1) (z.2)) (eta A a) d

--- DNF solver

def âˆ‚ (i : I) := i âˆ¨ -i
def âˆ‚-eq-neg-âˆ‚ (i : I) : Id I (âˆ‚ i) (âˆ‚ -i) := ref (âˆ‚ i)
def min (i j : I) := i âˆ§ j
def max (i j : I) := i âˆ¨ j
def âŠ• (i j : I) : I := (i âˆ§ -j) âˆ¨ (-i âˆ§ j)
def âŠ•-comm (i j : I) : Id I (âŠ• i j) (âŠ• j i) := ref (âŠ• i j)
def âˆ§-comm (i j : I) : Id I (i âˆ§ j) (j âˆ§ i) := ref (i âˆ§ j)
def âˆ¨-comm (i j : I) : Id I (i âˆ¨ j) (j âˆ¨ i) := ref (i âˆ¨ j)
def Â¬-of-âˆ§ (i j : I) : Id I -(i âˆ§ j) (-i âˆ¨ -j) := ref -(i âˆ§ j)
def Â¬-of-âˆ¨ (i j : I) : Id I -(i âˆ¨ j) (-i âˆ§ -j) := ref -(i âˆ¨ j)
def âˆ§-distrib-âˆ¨ (i j k : I) : Id I ((i âˆ¨ j) âˆ§ k) ((i âˆ§ k) âˆ¨ (j âˆ§ k)) := ref ((i âˆ¨ j) âˆ§ k)
def âˆ¨-distrib-âˆ§ (i j k : I) : Id I ((i âˆ§ j) âˆ¨ k) ((i âˆ¨ k) âˆ§ (j âˆ¨ k)) := ref ((i âˆ§ j) âˆ¨ k)
def âˆ§-assoc (i j k : I) : Id I (i âˆ§ (j âˆ§ k)) ((i âˆ§ j) âˆ§ k) := ref (i âˆ§ (j âˆ§ k))

--- Strict Equality on Partial and Interval Pretypes

def 1= : I -> V := Id I 1
def 1=1 : 1= 1 := ref 1
def UIP (A : V) (a b : A) (p q : Id A a b) : Id (Id A a b) p q := ref p
def Id-V (A : V) (a b : A) : V := Id A a b
def Id-ref (A : V) (a: A) : Id A a a := ref a
def â‰¤ (i j : I) := Id I (i âˆ§ j) i
def â‰¥ (i j : I) := â‰¤ j i
def âˆ§-split (i j : I) : Partial (1= i) (i âˆ§ j) := [(i = 1) (j = 1) â†’ 1=1]
def JË¢ (A : V) (C : Î  (a x : A), Id A a x -> V) (a x : A) (c : C a a (ref a)) (p : Id A a x) : C a x p := idJ A C a c x p
def JË¢-Î² (A : V) (C : Î  (a b : A), Id A a b -> V) (a : A) (c : C a a (ref a)) : Id (C a a (ref a)) (JË¢ A C a a c (ref a)) c := ref c
def rev (A : V) (a b : A) (p : Id A a b) : Id A b a := idJ A (Î» (a b : A) (_ : Id A a b), Id A b a) a (ref a) b p
def comp-Id (A : V) (a b c : A) (p : Id A a b) (q : Id A b c) : Id A a c := idJ A (Î» (b c : A) (_ : Id A b c), Id A a c) b p c q
def cong-Id (A B : V) (f : A -> B) (a b : A) (p : Id A a b) : Id B (f a) (f b) := idJ A (Î» (a b : A) (_ : Id A a b), Id B (f a) (f b)) a (ref (f a)) b p
def âˆ¨-left (i j : I) (p : 1= i) : 1= (i âˆ¨ j) := idJ I (Î» (i iâ€² : I) (_ : Id I i iâ€²), Id I 1 (iâ€² âˆ¨ j)) 1 1=1 i p
def âˆ¨-right (i j : I) (p : 1= j) : 1= (i âˆ¨ j) := âˆ¨-left j i p
def âˆ¨-max-left  (i j : I) : â‰¤ i (i âˆ¨ j) := ref i
def âˆ¨-max-right (i j : I) : â‰¤ j (i âˆ¨ j) := ref j
def âˆ§-1 (i j : I) (p : 1= (i âˆ§ j)) : 1= i := âˆ§-split i j p
def âˆ§-1â€² (i j : I) (p : 1= (i âˆ§ j)) : 1= i := cong-Id I I (Î» (k : I), k âˆ¨ i) 1 (i âˆ§ j) p
def âˆ§-min-left  (i j : I) : â‰¤ (i âˆ§ j) i := ref (i âˆ§ j)
def âˆ§-min-right (i j : I) : â‰¤ (i âˆ§ j) j := ref (i âˆ§ j)
def âˆ§-to-âˆ¨ (i j : I) (p : Id I (i âˆ§ j) i) : Id I (i âˆ¨ j) j
 := rev I j (i âˆ¨ j) (cong-Id I I (Î» (k : I), k âˆ¨ j) (i âˆ§ j) i p)
def Ï† (i : I) : Partial Uâ‚ (i âˆ¨ -i) := [(i = 0) â†’ U, (i = 1) â†’ U â†’ U]
def Ï†â€² (i : I) : Partial Uâ‚ (i âˆ¨ -i) := [(i = 1) â†’ U â†’ U, (i = 0) â†’ U]
def Ïˆ (i j : I) : Partial Uâ‚ (-i âˆ¨ i âˆ¨ (i âˆ§ j)) := [(i = 1) â†’ U, (i = 1) (j = 1) â†’ U, (i = 0) â†’ U â†’ U]
def Ï†-0 : PathP (<_> Uâ‚) (Ï† 0 1=1) U := <_> U
def Ï†-1 : PathP (<_> Uâ‚) (Ï† 1 1=1) (U â†’ U) := <_> U â†’ U
def Ï†-eq-Ï†â€² (i : I) : Id (Partial Uâ‚ (i âˆ¨ -i)) (Ï† i) (Ï†â€² i) := ref (Ï†â€² i)
def Ï (i j : I) : Partial Uâ‚ (-i âˆ¨ (i âˆ§ j)) := [(i = 0) â†’ U, (i = 1) (j = 1) â†’ U]
def Îº : Partial Uâ‚ 1 := [(1 = 1) â†’ U]
def Î¸ (A B : U) (a : A) (b : B) (Ï† : I) : PartialP [(Ï† = 0) â†’ A, (Ï† = 1) â†’ B] (Ï† âˆ¨ -Ï†) := [(Ï† = 0) â†’ a, (Ï† = 1) â†’ b]
def partial-app-test (A : U) (a : A) (Ï† : I) (p : 1= Ï†) : A := [(Ï† = 1) â†’ a] p
def 0-is-min (i : I) : â‰¤ 0 i := ref 0
def 1-is-max (i : I) : â‰¤ i 1 := ref i
def Îµ (A : U) : Partial A 0 := []
-- def I-nontriv (p : Id I 0 1) : ğŸ := Îµ ğŸ (rev I 0 1 p)
-- def 0â‰¥1-impl-absurd : (â‰¥ 0 1) â†’ ğŸ := I-nontriv

def â‰¤-asymm (i j : I) (p : â‰¤ i j) (q : â‰¤ j i) : Id I i j := comp-Id I i (i âˆ§ j) j (rev I (i âˆ§ j) i p) q
def â‰¤-refl (i : I) : â‰¤ i i := ref i
def â‰¤-trans (i j k : I) (p : â‰¤ i j) (q : â‰¤ j k) : â‰¤ i k
 := comp-Id I (i âˆ§ k) (i âˆ§ j) i
    (comp-Id I (i âˆ§ k) (i âˆ§ j âˆ§ k) (i âˆ§ j)
      (rev I (i âˆ§ j âˆ§ k) (i âˆ§ k) (cong-Id I I (min k) (i âˆ§ j) i p))
      (cong-Id I I (min i) (j âˆ§ k) j q)) p

--- Simplex Encoding

def Î”Â² := Î£ (i j : I), â‰¤ i j
def Î”Â²-1 : Î”Â² := (0, 0, ref 0)
def Î”Â²-2 : Î”Â² := (0, 1, ref 0)
def Î”Â²-3 : Î”Â² := (1, 1, ref 1)
def Î”Â²-1-2 : PathP (<_> Î”Â²) Î”Â²-1 Î”Â²-2 := <i> (0, i, ref 0)
def Î”Â²-2-3 : PathP (<_> Î”Â²) Î”Â²-2 Î”Â²-3 := <i> (i, 1, ref i)
def Î”Â²-1-3 : PathP (<_> Î”Â²) Î”Â²-1 Î”Â²-3 := <i> (i, i, ref i)

def Î”Â³ := Î£ (i j k : I), (â‰¤ i j) Ã— (â‰¤ j k)
def Î”Â³-1 : Î”Â³ := (0, 0, 0, ref 0, ref 0)
def Î”Â³-2 : Î”Â³ := (0, 0, 1, ref 0, ref 0)
def Î”Â³-3 : Î”Â³ := (0, 1, 1, ref 0, ref 1)
def Î”Â³-4 : Î”Â³ := (1, 1, 1, ref 1, ref 1)
def Î”Â³-1-2 : PathP (<_> Î”Â³) Î”Â³-1 Î”Â³-2 := <i> (0, 0, i, ref 0, ref 0)
def Î”Â³-2-3 : PathP (<_> Î”Â³) Î”Â³-2 Î”Â³-3 := <i> (0, i, 1, ref 0, ref i)
def Î”Â³-1-3 : PathP (<_> Î”Â³) Î”Â³-1 Î”Â³-3 := <i> (0, i, i, ref 0, ref i)
def Î”Â³-1-4 : PathP (<_> Î”Â³) Î”Â³-1 Î”Â³-4 := <i> (i, i, i, ref i, ref i)
def Î”Â³-2-4 : PathP (<_> Î”Â³) Î”Â³-2 Î”Â³-4 := <i> (i, i, 1, ref i, ref i)
def Î”Â³-3-4 : PathP (<_> Î”Â³) Î”Â³-3 Î”Â³-4 := <i> (i, 1, 1, ref i, ref 1)

--- Cubical Subtypes

def seg : PathP (<_> I) 0 1 := <i> i
def Partial-app (A : U) (i : I) (u : Partial A i) (p : 1= i) : A := u p
def Id-path (A : U) (a b : A) : Id A a b â†’ Path A a b := idJ A (Î» (a b : A) (_ : Id A a b), Path A a b) a (<_> a) b
def Partial' (A : U) (i : I) : V := Partial A i
def sub (A : U) (i : I) (u : Partial A i) : V := A [i â†¦ u]
def incâ€² (A : U) (i : I) (a : A) : sub A i [(i = 1) â†’ a] := inc A i a
def oucâ€² (A : U) (i : I) (u : Partial A i) (a : A [i â†¦ u]) : A := ouc a
def ouc'' (A : U) (i : I) (u : Partial A i) : A [i â†¦ u] -> A := Î» (a: A [i â†¦ u]), ouc a

def Pathâ€² (A : U) (a b : A) := Î  (i : I), A [âˆ‚ i â†¦ [(i = 0) â†’ a, (i = 1) â†’ b]]
def Path-Pathâ€² (A : U) (a b : A) (p : Path A a b) : Pathâ€² A a b := Î» (i : I), inc A (âˆ‚ i) (p @ i)
def Pathâ€²-Path (A : U) (a b : A) (p : Pathâ€² A a b) : Path A a b := <i> ouc (p i)
def Path-Pathâ€²-Path (A : U) (a b : A) (p : Path A a b)
  : Path (Path A a b) (Pathâ€²-Path A a b (Path-Pathâ€² A a b p)) p := <_> p
def Pathâ€²-Path-Pathâ€² (A : U) (a b : A) (p : Pathâ€² A a b)
  : PathP (<_> Pathâ€² A a b) (Path-Pathâ€² A a b (Pathâ€²-Path A a b p)) p := <_> p

--- Generalized Transport

def transp' (A: I â†’ U) (r: I) : A 0 -> A 1 := \ (a: A 0), transp (<i>A i) 0 a
def transpÂ¹ (A: U) (x y: A) (p : PathP (<_>A) x y) (i: I) := transp (<i> (\(_:A),A) (p @ i)) i x
def transpâ° (A: U) (x y: A) (p : PathP (<_>A) x y) := transp (<i> (\(_:A),A) (p @ i)) 0 x
def transpáµ (A B: U) (p : PathP (<_>U) A B) (i: I) := transp (<i> (\(_:U),U) (p @ i)) i A
def transpáµ‹ (A B: U) (p : PathP (<_>U) A B) := transp (<i> (\(_:U),U) (p @ i)) 0 A

def trans (A B : U) (p : PathP (<_> U) A B) : A â†’ B := transp p 0
def transâ»Â¹ (A B : U) (p : PathP (<_> U) A B) : B â†’ A := transp (<i> p @ -i) 0
def substâ€² (A: U) (P: A â†’ U) (a b: A) (p: Path A a b) (e: P a): P b := transp (<i> P (p @ i)) 0 e
def coerce (A B: U) (p: PathP (<_> U) A B): A â†’ B := Î» (x : A), trans A B p x
def transId (A : U) : A â†’ A := transp (<_> A) 1
def pcomp (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) : Path A a c
 := <i> hcomp A (âˆ‚ i) (Î» (j : I), [(i = 0) â†’ a, (i = 1) â†’ q @ j]) (p @ i)

def transâ»Â¹-trans (A B : U) (p : PathP (<_> U) A B) (b : B)
  : Path B (trans A B p (transâ»Â¹ A B p b)) b
 := <i> transp (<j> p @ i âˆ¨ j) i (transp (<j> p @ i âˆ¨ -j) i b)
def trans-transâ»Â¹ (A B : U) (p : PathP (<_> U) A B) (a : A)
  : Path A a (transâ»Â¹ A B p (trans A B p a))
 := <i> transp (<j> p @ i âˆ§ -j) -i (transp (<j> p @ i âˆ§ j) -i a)
def transFill (A B : U) (p : PathP (<_> U) A B) (a : A)
  : PathP p a (transp p 0 a)
 := <j> transp (<i> p @ i âˆ§ j) -j a
def fill (A : I â†’ U) (x : A 0)
  : PathP (<i> A i) x (transp (<i> A i) 0 x)
 := <j> transp (<i> A (i âˆ§ j)) -j x
def comp-Pathâ€² (A : U) (a b c : A) (p : Path A a b) (q : Path A b c)
  : Path A a c
 := transp (<i> Path A a (q @ i)) 0 p
def invâ€² (A : U) (a b : A) (p : Path A a b)
  : Path A b a
 := <i> hcomp A (âˆ‚ i) (Î» (j : I), [(i = 0) â†’ p @ j, (i = 1) â†’ a]) a

--- Homogeneous Composition

def hcomp' (A : U) (r : I) (u : I â†’ Partial A r) : A[r â†¦ u 0] -> A := \ (uâ‚€ : A[r â†¦ u 0]), hcomp A r u (ouc uâ‚€)
def hcomp-Îµ (A : U) (a : A) := hcomp A 0 (Î» (i : I), []) a
def hcomp-Îµâ†’id (A : U) (a : A) : Path A (hcomp-Îµ A a) a := <i> hcomp A i (Î» (j : I), [(i = 1) â†’ a]) a

def kan (A : U) (a b c d : A) (p : Path A a c) (q : Path A b d) (r : Path A a b) : Path A c d
 := <i> hcomp A (âˆ‚ i) (Î» (j : I), [(i = 0) â†’ p @ j, (i = 1) â†’ q @ j]) (r @ i)
def comp (A : I â†’ U) (r : I) (u : Î  (i : I), Partial (A i) r) (uâ‚€ : (A 0)[r â†¦ u 0]) : A 1
 := hcomp (A 1) r (Î» (i : I), [ (r = 1) â†’ transp (<j> A (i âˆ¨ j)) i (u i 1=1)]) (transp (<i> A i) 0 (ouc uâ‚€))
def ghcomp (A : U) (r : I) (u : I â†’ Partial A r) (uâ‚€ : A[r â†¦ u 0]) : A
 := hcomp A (âˆ‚ r) (Î» (j : I), [(r = 1) â†’ u j 1=1, (r = 0) â†’ ouc uâ‚€]) (ouc uâ‚€)
def ghcomp-Îµ (A : U) (a : A)
  : Path A (ghcomp A 0 (Î» (i : I), []) (inc A 0 a)) a := <_> a
def hfill (A : U) (r : I) (u : I â†’ Partial A r) (uâ‚€ : A[r â†¦ u 0]) (j : I)
 := hcomp A (-j âˆ¨ r) (Î» (i : I), [(r = 1) â†’ u (i âˆ§ j) 1=1, (j = 0) â†’ ouc uâ‚€]) (ouc uâ‚€)
def hfillâ€² (A : U) (r : I) (u : I â†’ Partial A r) (uâ‚€ : A[r â†¦ u 0]) : Path A (ouc uâ‚€) (hcomp A r u (ouc uâ‚€))
 := <j> hfill A r u uâ‚€ j
def trans-filler (A : U) (x y z : A) (p : Path A x y) (q : Path A y z) : PathP (<i> Path A x (q @ i)) p (pcomp A x y z p q)
 := <j i> hfill A (âˆ‚ i) (Î» (k : I), [(i = 0) â†’ x, (i = 1) â†’ q @ k]) (inc A (âˆ‚ i) (p @ i)) j
def trans-filler-p (A : U) (x y z : A) (p : Path A x y) (q : Path A y z) : PathP (<i> Path A x (q @ i)) p (pcomp A x y z p q)
 := <j i> hcomp A (-j âˆ¨ âˆ‚ i) (Î» (k : I), [(i = 0) â†’ x, (i = 1) â†’ q @ (k âˆ§ j), (j = 0) â†’ p @ i]) (p @ i)
def trans-filler-q (A : U) (x y z : A) (p : Path A x y) (q : Path A y z) : PathP (<i> Path A (p @ -i) z) q (pcomp A x y z p q)
 := <j i> hcomp A (-j âˆ¨ âˆ‚ i) (Î» (k : I), [(i = 0) â†’ p @ -j, (i = 1) â†’ q @ k, (j = 0) â†’ q @ i /\ k]) (p @ i \/ -j)

--- Groupoid Properties

def comp-Path (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) : Path A a c
 := <i> hcomp A (âˆ‚ i) (Î» (j : I), [(i = 0) â†’ a, (i = 1) â†’ q @ j]) (p @ i)
def comp-inv-Pathâ»Â¹ (A : U) (a b : A) (p : Path A a b)
  : Path (Path A a a) (comp-Path A a b a p (<i> p @ -i)) (<_> a)
 := <k j> hcomp A (âˆ‚ j âˆ¨ k) (Î» (i : I), [(j = 0) â†’ a, (j = 1) â†’ p @ -i âˆ§ -k, (k = 1) â†’ a]) (p @ j âˆ§ -k)
def comp-inv-Path (A : U) (a b : A) (p : Path A a b)
  : Path (Path A b b) (comp-Path A b a b (<i> p @ -i) p) (<_> b)
 := <j i> hcomp A (âˆ‚ i âˆ¨ j) (Î» (k : I), [(i = 0) â†’ b, (j = 1) â†’ b, (i = 1) â†’ p @ j \/ k]) (p @ -i âˆ¨ j)
def comp-Path-left (A : U) (a b : A) (p: Path A a b)
  : Path (Path A a b) p (comp-Path A a a b (<_> a) p)
 := <j i> hcomp A (âˆ‚ i âˆ¨ -j) (Î» (k : I), [(i = 0) â†’ a, (i = 1) â†’ p @ k, (j = 0) â†’ p @ i /\ k]) a
def comp-Path-right (A : U) (a b : A) (p: Path A a b)
  : Path (Path A a b) p (comp-Path A a b b p (<_> b))
 := <j i> hcomp A (âˆ‚ i âˆ¨ -j) (Î» (k : I), [(i = 0) â†’ a, (i = 1) â†’ b, (j = 0) â†’ p @ i]) (p @ i)
def comp-Path-assoc (A : U) (a b c d : A) (f : Path A a b) (g : Path A b c) (h : Path A c d)
  : Path (Path A a d) (comp-Path A a c d (comp-Path A a b c f g) h) (comp-Path A a b d f (comp-Path A b c d g h))
 := J A a (Î» (a : A) (b : A) (f : Path A a b), Î  (c d : A) (g : Path A b c) (h : Path A c d),
    Path (Path A a d) (comp-Path A a c d (comp-Path A a b c f g) h) (comp-Path A a b d f (comp-Path A b c d g h)))
    (Î» (c d : A) (g : Path A a c) (h : Path A c d),
      comp-Path (Path A a d)
         (comp-Path A a c d (comp-Path A a a c (<_> a) g) h)
         (comp-Path A a c d g h)
         (comp-Path A a a d (<_> a) (comp-Path A a c d g h))
         (<i> comp-Path A a c d (comp-Path-left A a c g @ -i) h)
         (comp-Path-left A a d (comp-Path A a c d g h))) b f c d g h

--- Reviewers of prover consistency should revise following
--- rules of Reality Checking (Internalizing of transp and hcomp)
--- also known as Simon Huber Equations:
--- https://simhu.github.io/misc/hcomp.pdf

{-  CCHM Equations:

    transpâ± N Ï† uâ‚€ = uâ‚€
    transpâ± U Ï† A = A
    transpâ± (Î  (x : A), B) Ï† uâ‚€ v = transpâ± B(x/w) Ï† (uâ‚€ w(i/0)), w = tFillâ»â± A Ï† v, v : A(i/1)
    transpâ± (Î£ (x : A), B) Ï† uâ‚€ = (transpâ± A Ï† (uâ‚€.1), transpâ± B(x/v) Ï†(uâ‚€.2)), v = tFillâ± A Ï† uâ‚€.1
    transpâ± (PathÊ² A v w) Ï† uâ‚€ = ã€ˆjã€‰ compâ± A [Ï† â†¦ uâ‚€ j, (j=0) â†¦ v, (j=1) â†¦ w] (uâ‚€ j)
    transpâ± G Ïˆ uâ‚€ = glue [Ï†(i/1) â†¦ tâ€²â‚] aâ€²â‚ : G(i/1), G = Glue [Ï† â†¦ (T,w)] A
    transpâ»â± A Ï† u = (transpâ± A(i/1âˆ’i) Ï† u)(i/1âˆ’i) : A(i/0)

    hcompâ± N [Ï† â†¦ 0] 0 = 0
    hcompâ± N [Ï† â†¦ S u] (S uâ‚€) = S (hcompâ± N [Ï† â†¦ u] uâ‚€)
    hcompâ± U [Ï† â†¦ E] A = Glue [Ï† â†¦ (E(i/1), equivâ± E(i/1âˆ’i))] A
    hcompâ± (Î  (x : A), B) [Ï† â†¦ u] uâ‚€ v = hcompâ± B(x/v) [Ï† â†¦ u v] (uâ‚€ v)
    hcompâ± (Î£ (x : A), B) [Ï† â†¦ u] uâ‚€ = (v(i/1), compâ± B(x/v) [Ï† â†¦ u.2] uâ‚€.2), v = hFillâ± A [Ï† â†¦ u.1] uâ‚€.1
    hcompâ± (PathÊ² A v w) [Ï† â†¦ u] uâ‚€ = ã€ˆjã€‰ hcompâ± A [ Ï† â†¦ u j, (j = 0) â†¦ v, (j = 1) â†¦ w ] (uâ‚€ j)
    hcompâ± G [Ïˆ â†¦ u] uâ‚€ = glue [Ï† â†¦ tâ‚] aâ‚ : G, G = Glue [Ï† â†¦ (T,w)] A, tâ‚ = u(i/1) : T,
           aâ‚ = unglue u(i/1) : A, glue [Ï† â†¦ tâ‚] a1 = tâ‚ : T

    tFillâ± A Ï† uâ‚€ = transpÊ² A(i/iâˆ§j) (Ï†âˆ¨(i=0)) uâ‚€ : A
    hFillâ± A [Ï† â†¦ u] uâ‚€ = hcompÊ² A [Ï† â†¦ u(i/iâˆ§j), (i=0) â†¦ uâ‚€] uâ‚€ : A
-}

--- Transport Equations Reality Check

def trans-Î  (A : I -> U) (B : Î  (i : I), A i -> U) (f : Î  (x : A 0), B 0 x) : Î  (x : A 1), B 1 x
 := transp (<i> Î  (x : A i), B i x) 0 f

def trans-Î£ (A : I -> U) (B : Î  (i : I), A i -> U) (z : Î£ (x : A 0), B 0 x) : Î£ (x : A 1), B 1 x
 := transp (<i> Î£ (x : A i), B i x) 0 z

def trans-Path (A B : I â†’ U) (P : Î  (i : I), PathP (<_> U) (A i) (B i)) (v : Î  (i : I), P i @ 0)
    (w : Î  (i : I), P i @ 1) (uâ‚€ : PathP (<i> P 0 @ i) (v 0) (w 0)) : PathP (<i> P 1 @ i) (v 1) (w 1)
 := transp (<i> PathP (P i) (v i) (w i)) 0 uâ‚€

def trans-Î â€² (A : I -> U) (B : Î  (i : I), A i -> U) (f : Î  (x : A 0), B 0 x) : Î  (x : A 1), B 1 x
 := Î» (x : A 1), transp (<j> B j (transFill (A 1) (A 0) (<i> A -i) x @ -j)) 0 (f (transp (<i> A -i) 0 x))

def trans-Î£â€² (A : I -> U) (B : Î  (i : I), A i -> U) (z : Î£ (x : A 0), B 0 x) : Î£ (x : A 1), B 1 x
 := (transp (<i> A i) 0 z.1, transp (<j> B j (transp (<i> A (i âˆ§ j)) -j z.1)) 0 z.2)

def trans-Pathâ€² (A B : I â†’ U) (P : Î  (i : I), PathP (<_> U) (A i) (B i)) (v : Î  (i : I), P i @ 0)
    (w : Î  (i : I), P i @ 1) (uâ‚€ : PathP (<i> P 0 @ i) (v 0) (w 0)) : PathP (<i> P 1 @ i) (v 1) (w 1)
 := <j> comp (Î» (i : I), P i @ j) (âˆ‚ j) (Î» (i : I), [(j = 0) â†’ v i, (j = 1) â†’ w i]) (inc (P 0 @ j) (âˆ‚ j) (uâ‚€ @ j))

def trans-Î -is-correct (A : I -> U) (B : Î  (i : I), A i -> U) (f : Î  (x : A 0), B 0 x)
  : Path (Î  (x : A 1), B 1 x) (trans-Î  A B f) (trans-Î â€² A B f) := <_> trans-Î  A B f

def trans-Î£-is-correct (A : I -> U) (B : Î  (i : I), A i -> U) (z : Î£ (x : A 0), B 0 x)
  : Path (Î£ (x : A 1), B 1 x) (trans-Î£ A B z) (trans-Î£â€² A B z) := <_> trans-Î£ A B z

def trans-Path-is-correct (A B : I â†’ U) (P : Î  (i : I), PathP (<_> U) (A i) (B i))
    (v : Î  (i : I), P i @ 0) (w : Î  (i : I), P i @ 1) (uâ‚€ : PathP (<i> P 0 @ i) (v 0) (w 0))
  : Path (PathP (<i> P 1 @ i) (v 1) (w 1)) (trans-Path A B P v w uâ‚€) (trans-Pathâ€² A B P v w uâ‚€)
 := <_> trans-Path A B P v w uâ‚€

--- Composition Equations Reality Check

def hcomp-U (r : I) (E : I â†’ Partial U r) (A : U[r â†¦ E 0])
 := hcomp U r E (ouc A)

def hcomp-Î  (A : U) (B : A â†’ U) (r : I)
    (u : I â†’ Partial (Î  (x : A), B x) r) (uâ‚€ : (Î  (x : A), B x)[r â†¦ u 0])
 := hcomp (Î  (x : A), B x) r u (ouc uâ‚€)

def hcomp-Î£ (A : U) (B : A â†’ U) (r : I) (u : I â†’ Partial (Î£ (x : A), B x) r) (uâ‚€ : (Î£ (x : A), B x)[r â†¦ u 0])
  : Î£ (x : A), B x
 := hcomp (Î£ (x : A), B x) r u (ouc uâ‚€)

def hcomp-Path (A : U) (v w : A) (r : I) (u : I â†’ Partial (Path A v w) r) (uâ‚€ : (Path A v w)[r â†¦ u 0])
 := hcomp (Path A v w) r u (ouc uâ‚€)

def hcomp-Î â€² (A : U) (B : A â†’ U) (r : I)
    (u : I â†’ Partial (Î  (x : A), B x) r) (uâ‚€ : (Î  (x : A), B x)[r â†¦ u 0])
 := Î» (v : A), hcomp (B v) r (Î» (k : I), [(r = 1) â†’ u k 1=1 v]) ((ouc uâ‚€) v)

def hcomp-Î£â€² (A : U) (B : A â†’ U) (r : I) (u : I â†’ Partial (Î£ (x : A), B x) r) (uâ‚€ : (Î£ (x : A), B x)[r â†¦ u 0]) : Î£ (x : A), B x
 := (hfill A r (Î» (k : I), [(r = 1) â†’ (u k 1=1).1]) (inc A r (ouc uâ‚€).1) 1,
     comp (Î» (i : I), B (hfill A r (Î» (k : I), [(r = 1) â†’ (u k 1=1).1]) (inc A r (ouc uâ‚€).1) i))
        r (Î» (k : I), [(r = 1) â†’ (u k 1=1).2]) (inc (B (ouc uâ‚€).1) r (ouc uâ‚€).2))

def hcomp-Pathâ€² (A : U) (v w : A) (r : I) (u : I â†’ Partial (Path A v w) r) (uâ‚€ : (Path A v w)[r â†¦ u 0]) : Path A v w
 := <j> hcomp A (r âˆ¨ âˆ‚ j) (Î» (i : I), [(r = 1) â†’ u i 1=1 @ j, (j = 0) â†’ v, (j = 1) â†’ w]) (ouc uâ‚€ @ j)

def hcomp-Î -is-correct (A : U) (B : A â†’ U) (r : I) (u : I â†’ Partial (Î  (x : A), B x) r) (uâ‚€ : (Î  (x : A), B x)[r â†¦ u 0])
  : Path (Î  (x : A), B x) (hcomp-Î  A B r u uâ‚€) (hcomp-Î â€² A B r u uâ‚€) := <_> hcomp-Î  A B r u uâ‚€

def hcomp-Î£-is-correct (A : U) (B : A â†’ U) (r : I) (u : I â†’ Partial (Î£ (x : A), B x) r) (uâ‚€ : (Î£ (x : A), B x)[r â†¦ u 0])
  : Path (Î£ (x : A), B x) (hcomp-Î£ A B r u uâ‚€) (hcomp-Î£â€² A B r u uâ‚€) := <_> hcomp-Î£ A B r u uâ‚€

def hcomp-Path-is-correct (A : U) (v w : A) (r : I) (u : I â†’ Partial (Path A v w) r) (uâ‚€ : (Path A v w)[r â†¦ u 0])
  : Path (Path A v w) (hcomp-Path A v w r u uâ‚€) (hcomp-Pathâ€² A v w r u uâ‚€)
 := <_> hcomp-Path A v w r u uâ‚€

--- Id functions and Propositional Canonicity

def idfun  (A : U) : A â†’ A := Î» (a : A), a
def idfunâ€² (A : U) : A â†’ A := Î» (a : A), transp (<i> A) 0 a
def idfunâ€³ (A : U) : A â†’ A := Î» (a : A), hcomp A 0 (Î» (i : I), []) a

def transpâ€²   (A : U) (j : I) (p : (I â†’ U) [j â†¦ [(j = 1) â†’ Î» (_ : I), A]]) := Î» (x: A), x
def transpâ€²â€²  (A : U) (j : I) (p : (I â†’ U) [j â†¦ [(j = 1) â†’ Î» (_ : I), A]]) := transp (<i> (ouc p) i) j
def transpâ€²â€²â€² (A : U) (j : I) (p : (I â†’ U) [j â†¦ [(j = 1) â†’ Î» (_ : I), A]]) := transp (<i> (Î» (_ : I), A) i) j

def idfun=idfunâ€²  (A : U) : Path (A â†’ A) (idfun A)  (idfunâ€² A)
 := <i> transp (<_> A) -i

def idfun=idfunâ€³  (A : U) : Path (A â†’ A) (idfun A)  (idfunâ€³ A)
 := <i> Î» (a : A), hcomp A -i (Î» (j : I), [(i = 0) â†’ a]) a

def idfunâ€²=idfunâ€³ (A : U) : Path (A â†’ A) (idfunâ€² A) (idfunâ€³ A)
 := comp-Path (A â†’ A) (idfunâ€² A) (idfun A) (idfunâ€³ A) (<i> idfun=idfunâ€² A @ -i) (idfun=idfunâ€³ A)

def ğŸ-contr : Î  (x : ğŸ), Path ğŸ x â˜…
 := indâ‚ (Î» (x : ğŸ), Path ğŸ x â˜…) (<_> â˜…)

def contr-impl-prop (A : U) (H : isContr A) : isProp A
 := Î» (a b : A), <i> hcomp A (âˆ‚ i) (Î» (j : I), [(i = 0) â†’ H.2 a @ j, (i = 1) â†’ H.2 b @ j]) H.1
