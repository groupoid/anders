{- Inductive Basis: https://anders.groupoid.space/foundations/mltt/inductive/
   - 0, 1, 2, W types;

   HoTT 1.8 The type of booleans
   HoTT 2.8 Unit type
   HoTT 5.1 Induction to inductive types
   HoTT 5.3 W-Types
   HoTT 5.4 Inductive types are initial algebras
   HoTT 5.5 Homotopy-in

   Copyright (c) Groupoid Infinity, 2014-2023. -}

module inductive where
import lib/foundations/univalent/path
import lib/foundations/mltt/either
option irrelevance true

-- Steve Awodey, Nicola Gambino, Kristina Sojakova
-- Inductive Types in Homotopy Type Theory
-- https://arxiv.org/pdf/1201.3898.pdf

-- Jasper Hugunin
-- Why not W?
-- https://jashug.github.io/papers/whynotw.pdf

-- Fredrik Nordvall Forsberg and Anton Setzer
-- A finite axiomatisation of inductive-inductive definitions
-- https://personal.cis.strath.ac.uk/fredrik.nordvall-forsberg/papers/indind_finite.pdf

-- Primitives: 0, 1, 2, W

def 0-ind (C: ğŸ â†’ U) (z: ğŸ) : C z := indâ‚€ (C z) z

def 1-rec (C: U) (x: C) : ğŸ â†’ C := indâ‚ (\(_:ğŸ), C) x
def 1-ind (C: ğŸ â†’ U) (x: C â˜…) : ĞŸ (z: ğŸ), C z := indâ‚ C x
def 1-Î² (C: U) (c: C): Path C (1-rec C c â˜…) c := idp C c
def 1-Î· (z: ğŸ) : Path ğŸ â˜… z := idp ğŸ â˜… -- ğŸ-irrelevance enabled

def 2-ind (C: ğŸ â†’ U) (x: C 0â‚‚) (y: C 1â‚‚) : ĞŸ (z: ğŸ), C z := indâ‚‚ C x y
def 2-rec (C: U) (x y: C) : ĞŸ (z: bool), C := indâ‚‚ (\(_:ğŸ), C) x y

def 2-Î²â‚ (C : ğŸ â†’ U) (f : Î  (x : ğŸ), C 0â‚‚) (g : Î  (y : ğŸ), C 1â‚‚)
  : PathP (<_>C 0â‚‚) (f 0â‚‚) (indâ‚‚ (Î» (x : ğŸ), C x) (f 0â‚‚) (g 1â‚‚) 0â‚‚)
 := <_> f 0â‚‚

def 2-Î²â‚‚ (C : ğŸ â†’ U) (f : Î  (x : ğŸ), C 0â‚‚) (g : Î  (y : ğŸ), C 1â‚‚)
  : PathP (<_>C 1â‚‚) (g 1â‚‚) (indâ‚‚ (Î» (x : ğŸ), C x) (f 0â‚‚) (g 1â‚‚) 1â‚‚)
 := <_> g 1â‚‚

def 2-Î· (c : ğŸ) : + (PathP (<_> ğŸ) c 0â‚‚) (PathP (<_> ğŸ) c 1â‚‚)
 := indâ‚‚ (Î» (c : ğŸ), + (PathP (<_> ğŸ) c 0â‚‚) (PathP (<_> ğŸ) c 1â‚‚))
         (0â‚‚, <_> 0â‚‚) (1â‚‚, <_> 1â‚‚) c

def Wâ€² (A : U) (B : A â†’ U) : U := W (x: A), B x
def supâ€² (A : U) (B : A â†’ U) (x : A) (f : B x â†’ Wâ€² A B) : Wâ€² A B := sup A B x f

def W-ind (A : U) (B : A â†’ U) (C : (W (x : A), B x) â†’ U)
    (g : Î  (x : A) (f : B x â†’ (W (x : A), B x)), (Î  (b : B x), C (f b)) â†’ C (sup A B x f))
    (w : W (x : A), B x)
  : C w := indáµ‚ A B C g w

def W-rec (A : U) (B : A â†’ U) (C : U)
    (g : Î  (x : A) (f : B x â†’ (W (x : A), B x)), (B x â†’ C) â†’ C)
    (w : W (x : A), B x)
  : C := indáµ‚ A B (Î» (_ : W (x : A), B x), C) g w

def W-indâ€² (A : U) (B : A â†’ U) (C : (W (x : A), B x) â†’ U)
    (Ï† : Î  (x : A) (f : B x â†’ (W (x : A), B x)), C (sup A B x f))
  : Î  (w : W (x : A), B x), C w
 := indáµ‚ A B C (Î» (x : A) (f : B x â†’ (W (x : A), B x)) (g : Î  (b : B x), C (f b)), Ï† x f)

def W-case (A : U) (B : A â†’ U) (C : U) (g : Î  (x : A) (f : B x â†’ (W (x : A), B x)), C)
  : (W (x : A), B x) â†’ C
 := W-indâ€² A B (Î» (_ : W (x : A), B x), C) g

def indáµ‚-Î² (A : U) (B : A â†’ U) (C : (W (x : A), B x) â†’ U)
    (g : Î  (x : A) (f : B x â†’ (W (x : A), B x)), (Î  (b : B x), C (f b)) â†’ C (sup A B x f))
    (a : A) (f : B a â†’ (W (x : A), B x))
  : PathP (<_> C (sup A B a f)) (indáµ‚ A B C g (sup A B a f)) (g a f (Î» (b : B a), indáµ‚ A B C g (f b)))
 := <_> g a f (Î» (b : B a), indáµ‚ A B C g (f b))

def W-projâ‚ (A : U) (B : A â†’ U) : (W (x : A), B x) â†’ A
 := W-case A B A (Î» (x : A) (f : B x â†’ (W (x : A), B x)), x)

def W-projâ‚‚ (A : U) (B : A â†’ U) : Î  (w : W (x : A), B x), B (W-projâ‚ A B w) â†’ (W (x : A), B x)
 := W-indâ€² A B (Î» (w : W (x : A), B x), B (W-projâ‚ A B w) â†’ (W (x : A), B x))
               (Î» (x : A) (f : B x â†’ (W (x : A), B x)), f)

def W-Î· (A : U) (B : A â†’ U)
  : Î  (w : W (x : A), B x), Path (W (x : A), B x) (sup A B (W-projâ‚ A B w) (W-projâ‚‚ A B w)) w
 := W-indâ€² A B (Î» (w : W (x : A), B x), Path (W (x : A), B x) (sup A B (W-projâ‚ A B w) (W-projâ‚‚ A B w)) w)
               (Î» (x : A) (f : B x â†’ (W (x : A), B x)), <_> sup A B x f)

def trans-W (A : I â†’ U) (B : Î  (i : I), A i â†’ U) (a : A 0) (f : B 0 a â†’ (W (x : A 0), B 0 x)) : W (x : A 1), B 1 x
 := sup (A 1) (B 1) (transp (<i> A i) 0 a) (transp (<i> B i (transFill (A 0) (A 1) (<j> A j) a @ i) â†’ (W (x : A i), B i x)) 0 f)

def trans-Wâ€² (A : I â†’ U) (B : Î  (i : I), A i â†’ U) (a : A 0) (f : B 0 a â†’ (W (x : A 0), B 0 x)) : W (x : A 1), B 1 x
 := transp (<i> W (x : A i), B i x) 0 (sup (A 0) (B 0) a f)

def trans-W-is-correct (A : I â†’ U) (B : Î  (i : I), A i â†’ U) (a : A 0) (f : B 0 a â†’ (W (x : A 0), B 0 x))
  : Path (W (x : A 1), B 1 x) (trans-W A B a f) (trans-Wâ€² A B a f)
 := <_> trans-W A B a f

def hcomp-W (A : U) (B : A â†’ U) (r : I) (a : I â†’ Partial A r)
    (f : Î  (i : I), PartialP [(r = 1) â†’ B (a i 1=1) â†’ (W (x : A), B x)] r)
    (aâ‚€ : A[r â†¦ a 0]) (fâ‚€ : (B (ouc aâ‚€) â†’ (W (x : A), B x))[r â†¦ f 0]) : W (x : A), B x
 := sup A B (hcomp A r a (ouc aâ‚€))
            (hcomp (B (hcomp A r a (ouc aâ‚€)) â†’ (W (x : A), B x)) r
                   (Î» (i : I), [(r = 1) â†’ Î» (b : B (a 1 1=1)), (f i 1=1) (transp (<j> B (a (-j âˆ¨ i) 1=1)) 0 b)])
                   (Î» (b : B (hcomp A r a (ouc aâ‚€))), (ouc fâ‚€) (transp (<j> B (hfill A r a aâ‚€ -j)) 0 b)))

def hcomp-Wâ€² (A : U) (B : A â†’ U) (r : I) (a : I â†’ Partial A r)
    (f : Î  (i : I), PartialP [(r = 1) â†’ B (a i 1=1) â†’ (W (x : A), B x)] r)
    (aâ‚€ : A[r â†¦ a 0]) (fâ‚€ : (B (ouc aâ‚€) â†’ (W (x : A), B x))[r â†¦ f 0]) : W (x : A), B x
 := hcomp (W (x : A), B x) r (Î» (i : I), [(r = 1) â†’ sup A B (a i 1=1) (f i 1=1)]) (sup A B (ouc aâ‚€) (ouc fâ‚€))

def hcomp-W-is-correct (A : U) (B : A â†’ U) (r : I) (a : I â†’ Partial A r)
    (f : Î  (i : I), PartialP [(r = 1) â†’ B (a i 1=1) â†’ (W (x : A), B x)] r)
    (aâ‚€ : A[r â†¦ a 0]) (fâ‚€ : (B (ouc aâ‚€) â†’ (W (x : A), B x))[r â†¦ f 0]) :
    Path (W (x : A), B x) (hcomp-W A B r a f aâ‚€ fâ‚€) (hcomp-Wâ€² A B r a f aâ‚€ fâ‚€) :=
<_> hcomp-W A B r a f aâ‚€ fâ‚€
