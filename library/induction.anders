module induction where
option girard true

-- Steve Awodey, Nicola Gambino, Kristina Sojakova
-- Inductive Types in Homotopy Type Theory
-- https://arxiv.org/pdf/1201.3898.pdf

def indáµ‚-Î² (A : U) (B : A â†’ U) (C : (W (x : A), B x) â†’ U)
    (g : Î  (x : A) (f : B x â†’ (W (x : A), B x)),
    (Î  (b : B x), C (f b)) â†’ C (sup A B x f))
    (a : A) (f : B a â†’ (W (x : A), B x))
 := g a f (Î» (b : B a), indáµ‚ A B C g (f b))

def indáµ‚-Î²â€² (A : U) (B : A â†’ U) (C : (W (x : A), B x) â†’ U)
    (g : Î  (x : A) (f : B x â†’ (W (x : A), B x)), (Î  (b : B x), C (f b)) â†’ C (sup A B x f))
    (a : A) (f : B a â†’ (W (x : A), B x))
 := indáµ‚ A B C g (sup A B a f)

def â„• := W (x : ğŸ), indâ‚‚ (Î» (_ : ğŸ), U) ğŸ ğŸ x
def â„•-ctor := indâ‚‚ (Î» (_ : ğŸ), U) ğŸ ğŸ

def zero : â„• := sup ğŸ â„•-ctor 0â‚‚ (indâ‚€ â„•)
def succ (n : â„•) : â„• := sup ğŸ â„•-ctor 1â‚‚ (Î» (x : ğŸ), n)

def ğŸâ†’â„• (C : â„• â†’ U) (f : ğŸ â†’ â„•) : C zero â†’ C (sup ğŸ â„•-ctor 0â‚‚ f)
 := transp (<i> C (sup ğŸ â„•-ctor 0â‚‚ (Î» (x : ğŸ), indâ‚€ (PathP (<_> â„•) (indâ‚€ â„• x) (f x)) x @ i))) 0

def ğŸâ†’â„• (C : â„• â†’ U) (f : ğŸ â†’ â„•) : C (succ (f â˜…)) â†’ C (sup ğŸ â„•-ctor 1â‚‚ f)
 := transp (<i> C (sup ğŸ â„•-ctor 1â‚‚ (Î» (x : ğŸ), indâ‚ (Î» (y : ğŸ), PathP (<_> â„•) (f â˜…) (f y)) (<_> f â˜…) x @ i))) 0

def â„•-ind (C : â„• â†’ U) (z : C zero) (s : Î  (n : â„•), C n â†’ C (succ n)) : Î  (n : â„•), C n
 := indáµ‚ ğŸ â„•-ctor C
    (indâ‚‚ (Î» (x : ğŸ), Î  (f : â„•-ctor x â†’ â„•), (Î  (b : â„•-ctor x), C (f b)) â†’ C (sup ğŸ â„•-ctor x f))
          (Î» (f : ğŸ â†’ â„•) (g : Î  (x : ğŸ), C (f x)), ğŸâ†’â„• C f z)
          (Î» (f : ğŸ â†’ â„•) (g : Î  (x : ğŸ), C (f x)), ğŸâ†’â„• C f (s (f â˜…) (g â˜…))))

def â„•-rec (C : U) (z : C) (s : â„• â†’ C â†’ C) : â„• â†’ C := â„•-ind (Î» (_ : â„•), C) z s
def â„•-iter (C : U) (z : C) (s : C â†’ C) : â„• â†’ C := â„•-rec C z (Î» (_ : â„•), s)
def â„•-case (C : U) (z s : C) : â„• â†’ C := â„•-iter C z (Î» (_ : C), s)
def N : U := â„•

def + (A B: U) : U := Î£ (x : ğŸ), indâ‚‚ (Î» (_ : ğŸ), U) A B x
def inl (A B : U) (a : A) : + A B := (0â‚‚, a)
def inr (A B : U) (b : B) : + A B := (1â‚‚, b)

def prod (A B: U) : U := Î£ (x : A), B

def maybe (A : U) : U := + ğŸ A
def nothing (A : U) : maybe A := (0â‚‚, â˜…)
def just (A : U) (a : A) : maybe A := (1â‚‚, a)

def Fin : â„• â†’ U := â„•-ind (Î» (_ : â„•), U) ğŸ (\(_: â„•), + ğŸ)
def Vec (A: U) : â„• â†’ U := â„•-ind (Î» (_ : â„•), U) A (\(_: â„•), prod A)
