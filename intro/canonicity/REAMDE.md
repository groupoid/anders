Canonicity
==========

# Prolog

Ğ¯ Ğ½Ğ°Ğ·Ğ¸Ğ²Ğ°Ñ Ñ†Ğµ Ñ‚Ñ€ÑŒĞ¾Ğ¼Ğ° ÑÑ‚Ğ°Ğ½Ğ°Ğ¼Ğ¸ Ğ²'ÑĞ·ĞºĞ¾ÑÑ‚Ñ– (ÑĞ¸Ğ½Ñ‚Ğ°ĞºÑĞ¸Ñ‡Ğ½Ğµ, Ğ¿Ñ€Ğ¾Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ñ–Ğ¹Ğ½Ğµ Ñ– Ğ³Ğ¾Ğ¼Ğ¾Ñ‚Ğ¾Ğ¿Ñ–Ñ‡Ğ½Ğµ) Ğ¼Ğ¸ÑĞ»ĞµĞ½Ğ½Ñ,
ÑĞºÑ– Ñ–ÑĞ½ÑƒÑÑ‚ÑŒ Ñƒ Ñ‡Ğ¾Ñ‚Ğ¸Ñ€ÑŒĞ¾Ñ… Ğ³Ğ»Ğ¸Ğ±Ğ¸Ğ½Ğ°Ñ… (ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ñ–Ñ—, Ğ¹Ğ¾Ğ³Ğ¸ Ğ³Ñ€Ğ¾Ñ‚ĞµĞ½Ğ´Ñ–ĞºĞ°, ĞºĞ¾Ğ³Ğ¾Ğ¼Ğ¾Ğ»Ğ¾Ğ³Ñ–Ñ—, ÑÑƒĞ¿ĞµÑ€Ğ³ĞµĞ¾Ğ¼ĞµÑ‚Ñ€Ñ–Ñ).

Ğ¡Ğ¿Ğ¾Ñ‡Ğ°Ñ‚ĞºÑƒ Ğ·Ñ– ÑÑ‚Ğ°Ğ½Ñƒ MLTT Ğ´Ğµ Ğ¼Ğ¸ÑĞ»ĞµĞ½Ğ½Ñ Ğ·Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ±ĞµÑ‚Ğ¾Ğ½Ğ½Ğµ (Ñ‚Ğ¾Ğ¼Ñƒ Ñ‰Ğ¾ Ğ¾Ğ±Ğ¼ĞµĞ¶ĞµĞ½Ğµ) Ñ– Ğ² Ğ¼Ğ°Ğ½Ğ´Ğ°Ğ»Ñ– Ğ²Ğ¸ Ğ²Ñ–Ğ´Ñ‡ÑƒĞ²Ğ°Ñ”Ñ‚Ğµ Ñ„Ñ–Ğ±Ñ€Ğ°Ñ†Ñ–Ğ¹Ğ½Ğµ Ğ´Ğ¸Ñ…Ğ°Ğ½Ğ½Ñ Ğ²Ğ¸ Ğ·Ğ°Ğ½ÑƒÑ€ÑÑ”Ñ‚ĞµÑÑ Ğ² Ñ–Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ğ¹Ğ½Ñ– Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾Ñ€Ğ¸, Ğ° Ğ¿Ğ¾Ñ‚Ñ–Ğ¼ Ğ·Ğ³Ğ¾Ğ´Ğ¾Ğ¼ Ğ²Ñ–Ğ´Ğ·Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ½Ñ Ñƒ ÑĞ°Ğ¼Ğ¸Ñ… Ñ–Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–ÑÑ… Ñ€Ğ¾Ğ·ÑƒĞ¼Ñ–ÑÑ‡Ğ¸ ÑˆĞ¾ Ğ¼Ğ¸ÑĞ»ĞµĞ½Ğ½Ñ Ñ–ÑĞ½ÑƒÑ” Ğ· Ğ´Ñ–Ñ€ĞºĞ°Ğ¼Ğ¸, ÑĞºÑ– Ğ½Ğµ Ğ¾Ğ±Ñ‡Ğ¸ÑĞ»ÑÑÑ‚ÑŒÑÑ.

Ğ”Ğµ Ğ·Ğ°ĞºĞ¾Ğ½Ğ¸ Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ— ÑƒÑĞºĞ»Ğ°Ğ´Ğ½ÑÑÑ‚ÑŒ Ğ²Ñ–Ğ·ĞµÑ€ÑƒĞ½ĞºĞ¸ Ñ‚Ğ°Ğº ÑˆĞ²Ğ¸Ğ´ĞºĞ¾ Ñ– Ñ‚Ğ°Ğº ÑĞºĞ»Ğ°Ğ´Ğ½Ğ¾, Ñ‰Ğ¾ Ğ¿ÑĞ¸Ñ…Ñ–ĞºĞ° Ğ½Ğ°Ñ‡Ğµ Ñ‚Ğ¾Ğ½Ğµ Ñƒ Ğ±Ğ¾Ğ»Ğ¾Ñ‚Ñ– Ğ³Ğ¾Ğ¼Ğ¾Ñ‚Ğ¾Ğ¿Ñ–Ñ‡Ğ½Ğ¾Ñ— Ğ²'ÑĞ·ĞºĞ¾ÑÑ‚Ñ–.

ĞÑÑ‚Ğ°Ğ½Ğ½Ñ–Ğ¹ ÑĞ¿Ğ¾ÑÑ–Ğ± Ğ¼Ğ¸ÑĞ»ĞµĞ½Ğ½Ñ Ñ–Ğ»Ñ–Ğ¼Ñ–Ğ½ÑƒÑ” Ğ¿Ğ¾Ğ²Ğ½Ñ–ÑÑ‚Ñ Ğ²ÑÑ– Ğ³Ğ¾Ğ¼Ğ¾Ñ‚Ğ¾Ğ¿Ñ–Ñ‡Ğ½Ñ– Ñ€Ñ–Ğ²Ğ½Ğ¾ÑÑ‚Ñ– Ğ² Ñ†Ñ–Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ– Ğ±ĞµÑĞºÑ–Ğ½ĞµÑ‡Ğ½Ğ¸Ñ… Ğ²ÑĞµÑĞ²Ñ–Ñ‚Ñ–Ğ² Ğ´Ğ²Ğ¾Ñ… Ñ‚Ğ¸Ğ¿Ñ–Ğ².

Ğ—Ğ°Ğ³Ğ°Ğ»Ğ¾Ğ¼ Ğ½Ğ°ÑˆĞµ Ğ¼Ğ¸ÑĞ»ĞµĞ½Ğ½Ñ Ğ¼Ğ¾Ğ¶Ğµ Ñ€Ğ¾Ğ±Ğ¸Ñ‚Ğ¸ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ¸ Ñ‚Ñ–Ğ»ÑŒĞºĞ¸ Ñ‚Ğ°ĞºĞ¸Ñ… Ñ‚Ğ¸Ğ¿Ñ–Ğ²:
1) Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ¸ Ñ„Ñ–Ğ±Ñ€Ğ°Ñ†Ñ–Ğ¹Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¸ÑĞ»ĞµĞ½Ğ½Ñ;
2) Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ¸ Ñ–Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ğ¹Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¸ÑĞ»ĞµĞ½Ğ½Ñ;
3) Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ¸ Ñ–Ğ½Ğ´ÑƒĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¸ÑĞ»ĞµĞ½Ğ½Ñ;
4) Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ¸ Ğ³ĞµĞ¾Ğ¼ĞµÑ‚Ñ€Ğ¸Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¸ÑĞ»ĞµĞ½Ğ½Ñ;
5) Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ¸ Ğ»Ñ–Ğ½Ñ–Ğ¹Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ¸ÑĞ»ĞµĞ½Ğ½Ñ (ĞºĞ²Ğ°Ğ½Ñ‚Ğ¾Ğ²Ğ° Ğ¼ĞµÑ…Ğ°Ğ½Ñ–ĞºĞ° Ñ– Ğ»Ñ–Ğ½Ñ–Ğ¹Ğ½Ğ° HoTT).

Ğ†ÑÑ‚Ğ¾Ñ‚Ğ° ÑĞºĞ° ĞµĞ»Ñ–Ğ¼Ñ–Ğ½ÑƒĞ²Ğ°Ğ»Ğ° Ğ²ÑÑ– Ñ–Ğ·Ğ¾Ğ¼Ğ¾Ñ€Ñ„Ñ–Ğ·Ğ¼Ğ¸ Ğ°Ğ¶ Ğ´Ğ¾ Ğ³Ğ¾Ğ¼Ğ¾Ñ‚Ğ¾Ğ¿Ñ–Ñ‡Ğ½Ğ¾Ñ— ĞºĞ°Ğ½Ğ¾Ğ½Ñ–Ñ‡Ğ½Ğ¾ÑÑ‚Ñ– Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ñ– Ğ½ĞµÑĞºÑ–Ğ½Ñ‡ĞµĞ½Ğ½Ğ¸Ñ… Ğ²ÑĞµÑĞ²Ñ–Ñ‚Ñ–Ğ² Ğ±Ğ°Ñ‡Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ Ñ‚Ğ°ĞºĞ¾Ñ ÑĞº Ğ²Ğ¾Ğ½Ğ° Ñ”.

# Definitions

## 1.1 Syntactic Canonicity

Syntactic canonicity (sometimes referred to as computational canonicity)
states that every closed term of a certain type reduces to a canonical
form using the internal reduction rules of the type theory. Specifically,
for the type of natural numbers (Nat), syntactic canonicity means that
every closed term t : Nat reduces to a numeral n (i.e., `t â‡“ n` where `n âˆˆ â„•`).

Formally: `Î  (t: â„•), Î£ (n: â„•), t ->* n`

## 1.2 Propositional canonicity

Propositional canonicity weakens syntactic canonicity by allowing
the equality between a closed term and a numeral to hold only up
to propositional equality `â‰¡`, rather than requiring direct computational reduction.

Formally: `Î  (t: â„•), Î£ (n: â„•), t â‰¡ n`

This means that, while t may not reduce directly to n, there
exists a derivable equality proof `p : t â‰¡ n` in the type theory.

## 1.3 Homotopy Canonicity

Homotopy canonicity is even weaker. Instead of requiring a definitional
or propositional equality, it only guarantees that every closed term is
homotopically equivalent to a numeral. This is relevant in frameworks
like HoTT, where identity types may not be strictly computable but still
behave coherently up to homotopy.

Formally, in HoTT: `Î  (t: â„•), Î£ (n: â„•), Path â„• t n`

# Canonicity Across Type Theories

|Type Theory|Syntactical|Propositional|Homotopy                           |
|-----------|-----------|-------------|-----------------------------------|
|MLTT       |        Yes| Yes         | Yes                               |
|HoTT       |         No| Yes         | Yes (Bocquet, Kapulkin, Sattler)  |
|CCHM       |        Yes| Yes         | Yes (Coquand, Huber, Sattler)     |

# Proof Sketches of Canonicity Results

## Failure of Syntactic Canonicity in HoTT

In Homotopy Type Theory, function extensionality and univalence introduce
higher-inductive types, making reduction ambiguous for closed terms.
Specifically, closed terms of Nat may contain elements that do not
normalize to a numeral but are still provably equal to one in homotopy.

## Proof Idea for Propositional Canonicity in HoTT

Bocquet and Kapulkin-Sattler established that every term of Nat is
propositionally equal to a numeral. The idea is to use a strict Rezk
completion of the syntactic model to construct a fibrant replacement
where each closed term can be shown to be propositionally equal to a numeral.

## Proof Idea for Homotopy Canonicity in Cubical Type Theory

Coquand, Huber, and Sattler proved homotopy canonicity using cubical models,
where paths (identity types) are explicitly represented as maps over the
interval type I. The crucial tool here is homogeneous composition (hcomp),
which ensures that any term in Nat is homotopically equivalent to a numeral,
enforcing canonicity in a structured manner.

Table 2: Mechanisms Ensuring Canonicity in Different Type Theories

| Type Theory | Mechanism for Canonicity                                              |
|-------------|-----------------------------------------------------------------------|
| MLTT        | Normalization via term reduction (syntactic canonicity)               |
| HoTT        | Homotopical fibrant replacement (propositional & homotopy canonicity) |
| CCHM        | Cubical paths + hcomp enforcing structured identity types             |

# Conclusion

Different type-theoretic frameworks impose different levels of canonicity.
While MLTT has full syntactic, propositional, and homotopy canonicity, HoTT
lacks syntactic canonicity but retains homotopy canonicity. Cubical HoTT
restores full canonicity using its explicit cubical structure. Understanding
these distinctions is crucial for developing computational and proof-theoretic
applications of type theory.

# Example of Violating Syntactic Canonicity

`â„•` defined in CCHM through `W`, `0`, `1`, `2` doesn't compute numerals expressions to same terms,
however they are propotionally canonical in CCHM though `hcomp`.

```
def â„•-ctor := ind_2 (Î» (f : ğŸ), U) ğŸ ğŸ
def â„• := W (x : ğŸ), â„•-ctor x
def zero : â„• := sup ğŸ â„•-ctor 0â‚‚ (indâ‚€ â„•)
def succ (n : â„•) : â„• := sup ğŸ â„•-ctor 1â‚‚ (Î» (x : ğŸ), n)

def ğŸâŸ¶â„• (C : â„• â†’ U) (f : ğŸ â†’ â„•) : C zero â†’ C (sup ğŸ â„•-ctor 0â‚‚ f)
 := transp (<i> C (sup ğŸ â„•-ctor 0â‚‚ (Î» (x : ğŸ), indâ‚€ (PathP (<_> â„•) (indâ‚€ â„• x) (f x)) x @ i))) 0

def ğŸâŸ¶â„• (C : â„• â†’ U) (f : ğŸ â†’ â„•) : C (succ (f â˜…)) â†’ C (sup ğŸ â„•-ctor 1â‚‚ f)
 := transp (<i> C (sup ğŸ â„•-ctor 1â‚‚ (Î» (x : ğŸ), indâ‚ (Î» (y : ğŸ), PathP (<_> â„•) (f â˜…) (f y)) (<_> f â˜…) x @ i))) 0

def â„•-ind (C : â„• â†’ U) (z : C zero) (s : Î  (n : â„•), C n â†’ C (succ n)) : Î  (n : â„•), C n
 := indáµ‚ ğŸ â„•-ctor C
    (indâ‚‚ (Î» (x : ğŸ), Î  (f : â„•-ctor x â†’ â„•), (Î  (b : â„•-ctor x), C (f b)) â†’ C (sup ğŸ â„•-ctor x f))
          (Î» (f : ğŸ â†’ â„•) (g : Î  (x : ğŸ), C (f x)), ğŸâŸ¶â„• C f z)
          (Î» (f : ğŸ â†’ â„•) (g : Î  (x : ğŸ), C (f x)), ğŸâŸ¶â„• C f (s (f â˜…) (g â˜…))))
```

## The Code

* `â„•-ctor` is defined as a two-point inductive type,
  which is essentially the structure of natural numbers,
  with two constructors 0 (zero) and 1 (successor).

* The function `â„•` defines the type of natural numbers
  by recursively applying the inductive constructor
  `â„•-ctor` to `W` (a parameter that will allow for recursion).

* `zero` defines the natural number 0, and `succ` defines the successor function,
   producing the next natural number.

* The terms `ğŸâŸ¶â„•` and `ğŸâŸ¶â„•` define the transport functions for zero and successor cases,
  respectively, using transposition (transp).

## Syntactic Canonicity

In the case of natural numbers through `W`, `0`, `1`, `2`, this would mean that terms involving
natural numbers reduce to either 0 or succ n for some n. In this case,
however, the terms seem to fail syntactic canonicity because of the way
they involve higher inductive types and path spaces.

* `PathP`: There is use of path types, which introduces potential non-canonical forms.
  For example, the `indâ‚€ (PathP (<_> â„•) ...`) terms are path-dependent terms,
  where the result depends on the path between natural numbers. This creates
  a situation where the terms cannot necessarily be reduced directly to 0 or
  succ n since the path spaces themselves may involve complex terms.

* `W`: The definition of `â„•` using `W` introduces a recursive structure.
  This is a higher inductive type, meaning that â„• will involve non-canonical
  terms due to the nature of the recursion and the transport between
  different levels of the inductive structure.

## Failures in Canonicity

* Non-normalizing terms: Because of the presence of path-dependent
  types `PathP` and recursive definitions involving higher inductive
  types like `W`, the terms may not always reduce to a simple form
  like 0 or succ n.

* Complexity in path spaces: The presence of path spaces (PathP)
  introduces a level of complexity where terms can fail to simplify
  to their normal form, especially if the path spaces themselves
  are complicated or not trivially reducible.

## Reformulating Canonicity for Natural Numbers

To reformulate canonicity for natural numbers built using this approach, consider the following:

1) Explicit normal forms: Instead of using higher inductive types and path
   spaces directly in the constructors of `â„•`, you could attempt to define
   explicit normal forms for each level of recursion. For example, if `â„•`
   is constructed inductively, the recursion should be designed to
   ensure that each term reduces to a canonical form (either 0 or succ n).

2) Defining a simplification rule: You could introduce simplification rules
   for the terms involving `PathP` and `indâ‚‚`. For example, if the term involves
   a path between two elements of the same type, it could simplify based on
   the structure of that path.

3) Weakening of transport functions: The use of transport
   functions (`ğŸâŸ¶â„•` and `ğŸâŸ¶â„•`) could be streamlined or simplified,
   possibly by ensuring that the terms they produce are more
   straightforward, avoiding the creation of complex path-dependent terms.

4) Avoiding path dependencies in constructors: If path dependencies
   are introduced in terms like `â„•-ctor` x, ensuring they do not lead
   to terms that require higher reductions may help maintain
   syntactic canonicity. This might involve constructing the natural
   number terms without relying on path-dependent constructs, focusing
   on simpler inductive rules.

## Conclusion

In summary, the failure of syntactic canonicity in the given example arises
due to the complexity introduced by path types, homotopy composition, and
the recursive definition via `W`. To reformulate it for canonicity, consider
reducing the reliance on path-dependent constructions and focusing on
explicit normal forms and simpler recursive definitions. Alternatively,
you could introduce simplification mechanisms for the terms involving
path spaces to ensure they normalize to canonical forms.

In the context of Constructive Cubical Higher Modalities (CCHM) and the
question of preserving syntactical canonicity when expressing natural
numbers `â„•` using the type constructors `W`, `0`, `1`, and `2` (which are
typically used in higher inductive type theory), there are significant
challenges. However, understanding these challenges in detail can help
identify potential paths to express natural numbers while preserving
syntactical canonicity.

### Understanding the Problem with Syntactical Canonicity

In type theory, syntactical canonicity refers to the property that
every term of a given type has a unique, reduced form (also called "normal form").
This is important because it ensures that terms can be reduced deterministically
and without ambiguity, which is often a crucial feature of constructive type theories.

When natural numbers are expressed using higher inductive
types (like `W` in your example), path-dependent types and
the recursive constructions involving homotopy (e.g., `W`,
`PathP`, and `indâ‚‚`) can introduce significant complexity. This
complexity can lead to the failure of syntactical canonicity, because:

Inductive structures involving path spaces (e.g., `PathP`) may not reduce
directly to canonical forms (like 0 or succ n) due to the presence of
higher-dimensional structures.

Recursion using `W` introduces non-trivial paths and depends on how the
recursion unfolds, which can result in terms that do not have simple normal forms.

Homotopy-theoretic aspects (like `hcomp`, `indâ‚‚`) typically introduce more
flexibility in the way terms are constructed and reduced, which makes
maintaining syntactic canonicity more difficult.

### Can Nat in W, 0, 1, 2 Preserve Syntactical Canonicity in CCHM?

Expressing natural numbers `â„•` using the approach youâ€™ve described (via `W`, `0`, `1`,
and `2` constructors) does not preserve syntactical canonicity in the standard
sense within CCHM. The introduction of higher inductive types, especially
the use of path-dependent terms, creates structures that do not always
reduce directly to canonical forms.

More specifically, the failure of canonicity is often a consequence of the following:

* Path spaces and homotopies: When `W` and path-dependent types are used,
  it introduces an extra layer of complexity, meaning terms in `â„•` might
  reduce to non-normal forms, and paths between elements in `â„•` can be non-trivial.

* Higher inductive types: The construction of `â„•` via `W` leads to a
  structure that does not admit a simple reduction to 0 or succ n.
  The recursion over `W` induces terms that involve complex higher-dimensional
  paths, making it hard to guarantee that each term will have a canonical form.

### Is This a Dead End, or Can It Be Fixed?

It is a dead and and can be fixed!

There are established results in type theory, particularly in homotopy
type theory and constructive type theories, which show that the use of
higher inductive types can break syntactical canonicity. In fact, this
has been the subject of study, and there are theorems stating that higher
inductive types generally do not preserve syntactical canonicity.

However, this does not mean that expressing natural numbers via `W` and
path-dependent constructions is entirely unworkable. Instead, it means that:

* You may need to reconsider how you define your natural numbers
  and possibly avoid certain path-dependent constructions if you
  want to maintain syntactic canonicity.

* It might be possible to use simple inductive types or other definitions
  of `â„•` that avoid the pitfalls of higher inductive types while still
  respecting constructive and homotopical principles.

* Direct inductive definition of `â„•`: One way to preserve canonicity is to define

