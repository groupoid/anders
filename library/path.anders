{- Path Type:
   - Path Equality;
   - Computational properties;
   - Interval and De Morgan laws;
   - Generalized Transport;
   - Strict equality on partial and interval pretypes;
   - Cubical subtypes;
   - Generalized Homogeneous Composition;

   HoTT 1.12 Identity types
   HoTT 1.12.1 Path induction
   HoTT 2.1 Types are higher groupoids
   HoTT 2.11 Identity type
   HoTT 3.11 Contractibility
   HoTT 6.2 Induction principles and dependent paths.

   Copyright (c) Groupoid Infinity, 2014-2022. -}

module path where

-- Proto

def âˆ˜áµ€ (Î± Î² Î³: U) : U := (Î² â†’ Î³) â†’ (Î± â†’ Î²) â†’ (Î± â†’ Î³)
def âˆ˜ (Î± Î² Î³ : U) : âˆ˜áµ€ Î± Î² Î³ := Î» (g: Î² â†’ Î³) (f: Î± â†’ Î²) (x: Î±), g (f x)
def idáµ€ (Î±: U): U := Î± â†’ Î±
def id (Î± : U) (a : Î±) : Î± := a
def const (Î± Î² : U) : Î± â†’ Î² â†’ Î± := Î» (a : Î±) (b : Î²), a
def LineP (A : I â†’ U) : V := Î  (i : I), A i

-- Path Equality

def Path (A : U) (x y : A) : U := PathP (<_> A) x y
def idp (A : U) (x : A) : Path A x x := <_> x
def singl (A: U) (a: A): U := Î£ (x: A), Path A a x
def eta (A: U) (a: A): singl A a := (a, idp A a)
def sym (A: U) (a b : A) (p : Path A a b) : Path A b a := <i> p @ -i
def contr (A : U) (a b : A) (p : Path A a b) : Path (singl A a) (eta A a) (b, p) := <i> (p @ i, <j> p @ i /\ j)
def isContr (A: U) : U := Î£ (x: A), Î  (y: A), Path A x y
def isContrSingl (A : U) (a : A) : isContr (singl A a) := ((a,idp A a),(\ (z:singl A a), contr A a z.1 z.2))
def cong (A B : U) (f : A â†’ B) (a b : A) (p : Path A a b) : Path B (f a) (f b) := <i> f (p @ i)
def ap (A: U) (a x: A) (B: A â†’ U) (f: A â†’ B a) (b: B a) (p: Path A a x): Path (B a) (f a) (f x) := <i> f (p @ i)
def inv (A: U) (a b: A) (p: Path A a b): Path A b a := <i> p @ -i
def Path-Î· (A : U) (x y : A) (p : Path A x y) : Path (Path A x y) p (<i> p @ i) := <_> p
def idp-left (A : U) (x y : A) (p : Path A x y) : Path (Path A x x) (<_> x) (<_> p @ 0) := <_ _> x
def idp-right (A : U) (x y : A) (p : Path A x y) : Path (Path A y y) (<_> y) (<_> p @ 1) := <_ _> y
def sym-sym-eq-idp (A : U) (x y : A) (p : Path A x y) : Path (Path A x y) p (sym A y x (sym A x y p)) := <_> p
def section (A B : U) (f : A -> B) (g : B -> A) : U := Î  (b : B), Path B (f (g b)) b
def retract (A B : U) (f : A -> B) (g : B -> A) : U := Î  (a : A), Path A (g (f a)) a
def hmtpy (A : U) (x y : A) (p : Path A x y) : Path (Path A x x) (<_> x) (<i> p @ i /\ -i) := <j i> p @ j /\ i /\ -i
def plam (A : U) (f : I â†’ A) : Path A (f 0) (f 1) := <i> f i
def elim (A : U) (a b : A) (p : Path A a b) : I â†’ A := Î» (i : I), p @ i
def plam-elim (A : U) (f : I â†’ A) : Id (I â†’ A) (elim A (f 0) (f 1) (plam A f)) f := ref f
def elim-plam (A : U) (a b : A) (p : Path A a b) : Path (Path A a b) (plam A (elim A a b p)) p := <_> p
def isProp (A : U) : U := Î  (a b : A), Path A a b
def isSet (A : U) : U := Î  (a b : A) (a0 b0 : Path A a b), Path (Path A a b) a0 b0
def isGroupoid (A : U) : U := Î  (a b : A) (x y : Path A a b)
               (i j : Path (Path A a b) x y), Path (Path (Path A a b) x y) i j

def SET : Uâ‚ := Î£ (X : U), isSet X

-- Computational Properties

def transport (A B: U) (p : PathP (<_> U) A B) (a: A): B := transp p 0 a
def trans_comp (A : U) (a : A) : Path A a (transport A A (<i> A) a) := <j> transp (<_> A) -j a
def subst (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b := transp (<i> P (p @ i)) 0 e
def D (A : U) : Uâ‚ â‰” Î  (x y : A), Path A x y â†’ U
def J (A: U) (x: A) (C: D A) (d: C x x (idp A x)) (y: A) (p: Path A x y): C x y p
 := subst (singl A x) (\ (z: singl A x), C x (z.1) (z.2)) (eta A x) (y, p) (contr A x y p) d
def subst_comp (A: U) (P: A â†’ U) (a: A) (e: P a): Path (P a) e (subst A P a a (idp A a) e) := trans_comp (P a) e
def J-Î² (A : U) (a : A) (C : D A) (d: C a a (idp A a)) : Path (C a a (idp A a)) d (J A a C d a (idp A a))
 := subst_comp (singl A a) (\ (z: singl A a), C a (z.1) (z.2)) (eta A a) d

-- (<i j> p @ i /\ j) @ 0 â‰¡ <j> p @ 0 /\ j â‰¡ <j> p @ 0 â‰¡ <_> a,
-- (<i j> p @ i /\ j) @ 1 â‰¡ <j> p @ 1 /\ j â‰¡ <j> p @ j â‰¡ p,
-- but it doesnâ€™t check since <j> p @ i /\ j : Path A (p @ i /\ 0) (p @ i /\ 1) â‰¡ Path A a (p @ i),
-- which is â€œPath A a aâ€ only propositionally
-- def K (A : U) (a : A) (p : Path A a a) : Path (Path A a a) (<_> a) p := <i j> p @ i /\ j

-- DNF solver

def âˆ‚ (i : I) := i âˆ¨ -i
def âˆ‚-eq-neg-âˆ‚ (i : I) : Id I (âˆ‚ i) (âˆ‚ -i) := ref (âˆ‚ i)

def min (i j : I) := i âˆ§ j
def max (i j : I) := i âˆ¨ j

def âŠ• (i j : I) : I := (i âˆ§ -j) âˆ¨ (-i âˆ§ j)
def âŠ•-comm (i j : I) : Id I (âŠ• i j) (âŠ• j i) := ref (âŠ• i j)
def âˆ§-comm (i j : I) : Id I (i âˆ§ j) (j âˆ§ i) := ref (i âˆ§ j)
def âˆ¨-comm (i j : I) : Id I (i âˆ¨ j) (j âˆ¨ i) := ref (i âˆ¨ j)
def Â¬-of-âˆ§ (i j : I) : Id I -(i âˆ§ j) (-i âˆ¨ -j) := ref -(i âˆ§ j)
def Â¬-of-âˆ¨ (i j : I) : Id I -(i âˆ¨ j) (-i âˆ§ -j) := ref -(i âˆ¨ j)
def âˆ§-distrib-âˆ¨ (i j k : I) : Id I ((i âˆ¨ j) âˆ§ k) ((i âˆ§ k) âˆ¨ (j âˆ§ k)) := ref ((i âˆ¨ j) âˆ§ k)
def âˆ¨-distrib-âˆ§ (i j k : I) : Id I ((i âˆ§ j) âˆ¨ k) ((i âˆ¨ k) âˆ§ (j âˆ¨ k)) := ref ((i âˆ§ j) âˆ¨ k)
def âˆ§-assoc (i j k : I) : Id I (i âˆ§ (j âˆ§ k)) ((i âˆ§ j) âˆ§ k) := ref (i âˆ§ (j âˆ§ k))

-- Strict Equality on Partial and Interval Pretypes

def 1= : I -> V := Id I 1
def 1=1 : 1= 1 := ref 1
def UIP (A : V) (a b : A) (p q : Id A a b) : Id (Id A a b) p q := ref p

def JË¢ (A : V) (B : Î  (a b : A), Id A a b -> V) (a b : A) (d : B a a (ref a)) (p : Id A a b) : B a b p := idJ A B a d b p
def JË¢-Î² (A : V) (B : Î  (a b : A), Id A a b -> V) (a : A) (d : B a a (ref a)) : Id (B a a (ref a)) (JË¢ A B a a d (ref a)) d := ref d
def rev (A : V) (a b : A) (p : Id A a b) : Id A b a := idJ A (Î» (a b : A) (_ : Id A a b), Id A b a) a (ref a) b p
def comp-Id (A : V) (a b c : A) (p : Id A a b) (q : Id A b c) : Id A a c := idJ A (Î» (b c : A) (_ : Id A b c), Id A a c) b p c q
def cong-Id (A B : V) (f : A -> B) (a b : A) (p : Id A a b) : Id B (f a) (f b) := idJ A (Î» (a b : A) (_ : Id A a b), Id B (f a) (f b)) a (ref (f a)) b p

def Ï† (i : I) : Partial Uâ‚ (i âˆ¨ -i) := [(i = 0) â†’ U, (i = 1) â†’ U â†’ U]
def Ï†â€² (i : I) : Partial Uâ‚ (i âˆ¨ -i) := [(i = 1) â†’ U â†’ U, (i = 0) â†’ U]
def Ïˆ (i j : I) : Partial Uâ‚ (-i âˆ¨ i âˆ¨ (i âˆ§ j)) := [(i = 1) â†’ U, (i = 1) (j = 1) â†’ U, (i = 0) â†’ U â†’ U]
def Ï†-0 : PathP (<_> Uâ‚) (Ï† 0 1=1) U := <_> U
def Ï†-1 : PathP (<_> Uâ‚) (Ï† 1 1=1) (U â†’ U) := <_> U â†’ U
def Ï†-eq-Ï†â€² (i : I) : Id (Partial Uâ‚ (i âˆ¨ -i)) (Ï† i) (Ï†â€² i) := ref (Ï†â€² i)
def Ï (i j : I) : Partial Uâ‚ (-i âˆ¨ (i âˆ§ j)) := [(i = 0) â†’ U, (i = 1) (j = 1) â†’ U]
def Îº : Partial Uâ‚ 1 := [(1 = 1) â†’ U]
def Î¸ (A B : U) (a : A) (b : B) (Ï† : I) : PartialP [(Ï† = 0) â†’ A, (Ï† = 1) â†’ B] (Ï† âˆ¨ -Ï†) := [(Ï† = 0) â†’ a, (Ï† = 1) â†’ b]
def partial-app-test (A : U) (a : A) (Ï† : I) (p : 1= Ï†) : A := [(Ï† = 1) â†’ a] p

def â‰¤ (i j : I) := Id I (i âˆ§ j) i
def â‰¥ (i j : I) := â‰¤ j i

def âˆ§-split (i j : I) : Partial (1= i) (i âˆ§ j) := [(i = 1) (j = 1) â†’ 1=1]
def âˆ¨-left (i j : I) (p : 1= i) : 1= (i âˆ¨ j) := idJ I (Î» (i iâ€² : I) (_ : Id I i iâ€²), Id I 1 (iâ€² âˆ¨ j)) 1 1=1 i p
def âˆ¨-right (i j : I) (p : 1= j) : 1= (i âˆ¨ j) := âˆ¨-left j i p -- works due to commutativity of âˆ¨
def âˆ§-1 (i j : I) (p : 1= (i âˆ§ j)) : 1= i := âˆ§-split i j p
def âˆ§-1â€² (i j : I) (p : 1= (i âˆ§ j)) : 1= i := cong-Id I I (Î» (k : I), k âˆ¨ i) 1 (i âˆ§ j) p
def âˆ§-min-left  (i j : I) : â‰¤ (i âˆ§ j) i := ref (i âˆ§ j)
def âˆ§-min-right (i j : I) : â‰¤ (i âˆ§ j) j := ref (i âˆ§ j)
def âˆ¨-max-left  (i j : I) : â‰¤ i (i âˆ¨ j) := ref i
def âˆ¨-max-right (i j : I) : â‰¤ j (i âˆ¨ j) := ref j
def âˆ§-to-âˆ¨ (i j : I) (p : Id I (i âˆ§ j) i) : Id I (i âˆ¨ j) j := rev I j (i âˆ¨ j) (cong-Id I I (Î» (k : I), k âˆ¨ j) (i âˆ§ j) i p)

def â‰¤-asymm (i j : I) (p : â‰¤ i j) (q : â‰¤ j i) : Id I i j := comp-Id I i (i âˆ§ j) j (rev I (i âˆ§ j) i p) q
def â‰¤-refl (i : I) : â‰¤ i i := ref i
def â‰¤-trans (i j k : I) (p : â‰¤ i j) (q : â‰¤ j k) : â‰¤ i k
 := comp-Id I (i âˆ§ k) (i âˆ§ j) i
    (comp-Id I (i âˆ§ k) (i âˆ§ j âˆ§ k) (i âˆ§ j)
      (rev I (i âˆ§ j âˆ§ k) (i âˆ§ k) (cong-Id I I (min k) (i âˆ§ j) i p))
      (cong-Id I I (min i) (j âˆ§ k) j q)) p

def 0-is-min (i : I) : â‰¤ 0 i := ref 0
def 1-is-max (i : I) : â‰¤ i 1 := ref i

def Î”Â² := Î£ (i j : I), â‰¤ i j

def Î”Â²-1 : Î”Â² := (0, 0, ref 0)
def Î”Â²-2 : Î”Â² := (0, 1, ref 0)
def Î”Â²-3 : Î”Â² := (1, 1, ref 1)

def Î”Â²-1-2 : PathP (<_> Î”Â²) Î”Â²-1 Î”Â²-2 := <i> (0, i, ref 0)
def Î”Â²-2-3 : PathP (<_> Î”Â²) Î”Â²-2 Î”Â²-3 := <i> (i, 1, ref i)
def Î”Â²-1-3 : PathP (<_> Î”Â²) Î”Â²-1 Î”Â²-3 := <i> (i, i, ref i)

def Î”Â³ := Î£ (i j k : I), (â‰¤ i j) Ã— (â‰¤ j k)

def Î”Â³-1 : Î”Â³ := (0, 0, 0, ref 0, ref 0)
def Î”Â³-2 : Î”Â³ := (0, 0, 1, ref 0, ref 0)
def Î”Â³-3 : Î”Â³ := (0, 1, 1, ref 0, ref 1)
def Î”Â³-4 : Î”Â³ := (1, 1, 1, ref 1, ref 1)

def Î”Â³-1-2 : PathP (<_> Î”Â³) Î”Â³-1 Î”Â³-2 := <i> (0, 0, i, ref 0, ref 0)
def Î”Â³-2-3 : PathP (<_> Î”Â³) Î”Â³-2 Î”Â³-3 := <i> (0, i, 1, ref 0, ref i)
def Î”Â³-1-3 : PathP (<_> Î”Â³) Î”Â³-1 Î”Â³-3 := <i> (0, i, i, ref 0, ref i)

def Î”Â³-1-4 : PathP (<_> Î”Â³) Î”Â³-1 Î”Â³-4 := <i> (i, i, i, ref i, ref i)
def Î”Â³-2-4 : PathP (<_> Î”Â³) Î”Â³-2 Î”Â³-4 := <i> (i, i, 1, ref i, ref i)
def Î”Â³-3-4 : PathP (<_> Î”Â³) Î”Â³-3 Î”Â³-4 := <i> (i, 1, 1, ref i, ref 1)

def Îµ (A : U) : Partial A 0 := []
def âŠ¥ := Î  (A : U), A

def I-nontriv (p : Id I 0 1) : âŠ¥ := Î» (A : U), Îµ A (rev I 0 1 p)
def 0â‰¥1-impl-absurd : (â‰¥ 0 1) â†’ âŠ¥ := I-nontriv

-- Cubical Subtypes

def seg : PathP (<_> I) 0 1 := <i> i
def Partial-app (A : U) (i : I) (u : Partial A i) (p : 1= i) : A := u p
def Id-path (A : U) (a b : A) : Id A a b â†’ Path A a b := idJ A (Î» (a b : A) (_ : Id A a b), Path A a b) a (<_> a) b
def Partialâ€² (A : U) (i : I) := Partial A i
def sub (A : U) (i : I) (u : Partial A i) : V := A[i â†¦ u]
def incâ€² (A : U) (i : I) (a : A) : sub A i [(i = 1) â†’ a] := inc A i a
def oucâ€² (A : U) (i : I) (u : Partial A i) (a : A[i â†¦ u]) : A := ouc a

-- Simon Huber equations: http://www.cse.chalmers.se/~simonhu/misc/hcomp.pdf

-- transpâ± N Ï† uâ‚€ = uâ‚€
-- transpâ± U Ï† A = A
-- transpâ± (Î  (x : A), B) Ï† uâ‚€ v = transpâ± B(x/w) Ï† (uâ‚€ w(i/0)), where [ w = transpFillâ»â± A Ï† v, v : A(i/1) ]
-- transpâ± (Î£ (x : A), B) Ï† uâ‚€ = (transpâ± A Ï† (uâ‚€.1),transpâ± B(x/v) Ï†(uâ‚€.2)), where [ v = transpFillâ± A Ï† uâ‚€.1 ]
-- transpâ± (PathÊ² A v w) Ï† uâ‚€ = ã€ˆjã€‰compâ± A [Ï† â†¦ uâ‚€ j, (j=0) â†¦ v, (j=1) â†¦ w] (uâ‚€ j), where [ u : A(j/0), v : A(j/1) ]
-- transpâ± (Glue [Ï† â†¦ (T,w)] A) Ïˆ uâ‚€ = glue [Ï†(i/1) â†¦ tâ€²â‚] aâ€²â‚ : B(i/1)

-- hcompâ± N [Ï† â†¦ 0] 0 = 0
-- hcompâ± N [Ï† â†¦ S u] (S uâ‚€) = S (hcompâ± N [Ï† â†¦ u] uâ‚€)
-- hcompâ± U [Ï† â†¦ E] A = Glue [Ï† â†¦ (E(i/1), equivâ± E(i/1âˆ’i))] A
-- hcompâ± (Î  (x : A), B) [Ï† â†¦ u] uâ‚€ v = hcompâ± B(x/v) [Ï† â†¦ u v] (uâ‚€ v)
-- hcompâ± (Î£ (x : A), B) [Ï† â†¦ u] uâ‚€ = (v(i/1), compâ± B(x/v) [Ï† â†¦ u.2] uâ‚€.2), where [ v = hfillâ± A [Ï† â†¦ u.1] uâ‚€.1 ]
-- hcompâ± (PathÊ² A v w) [Ï† â†¦ u] uâ‚€ = ã€ˆjã€‰ hcompâ± A [ Ï† â†¦ u j, (j = 0) â†¦ v, (j = 1) â†¦ w ] (uâ‚€ j)
-- hcompâ± (Glue [Ï† â†¦ (T,w)] A) [Ïˆ â†¦ u] uâ‚€ = glue [Ï† â†¦ tâ‚] aâ‚ = glue [Ï† â†¦ u(i/1)] (unglue u(i/1))
--   = u(i/1) : Glue [Ï† â†¦ (T,w)] A, where [ tâ‚ = u(i/1) : T, aâ‚ = unglue u(i/1) : A, glue [Ï† â†¦ tâ‚] a1 = tâ‚ : T ]

-- transpâ»â± A Ï† u = (transpâ± A(i/1âˆ’i) Ï† u)(i/1âˆ’i) : A(i/0)
-- transpFillâ± A Ï† uâ‚€ = transpÊ² A(i/iâˆ§j) (Ï†âˆ¨(i=0)) uâ‚€ : A
-- hfillâ± A [Ï† â†¦ u] uâ‚€ = hcompÊ² A [Ï† â†¦ u(i/iâˆ§j), (i=0) â†¦ uâ‚€] uâ‚€ : A

-- Generalized Transport

def transpâ€² (A : U) (j : I) (p : (I â†’ U) [j â†¦ [(j = 1) â†’ Î» (_ : I), A]]) := transp (<i> (ouc p) i) j
def trans (A B : U) (p : PathP (<_> U) A B) : A â†’ B := transp p 0
def transâ»Â¹ (A B : U) (p : PathP (<_> U) A B) : B â†’ A := transp (<i> p @ -i) 0
def substâ€² (A: U) (P: A â†’ U) (a b: A) (p: Path A a b) (e: P a): P b := transp (<i> P (p @ i)) 0 e
def coerce (A B: U) (p: PathP (<_> U) A B): A â†’ B := Î» (x : A), trans A B p x
def pcomp (A: U) (a b c: A) (p: Path A a b) (q: Path A b c): Path A a c := subst A (Path A a) b c q p
def transId (A : U) : A â†’ A := transp (<_> A) 1

def transâ»Â¹-trans (A B : U) (p : PathP (<_> U) A B) (b : B) : Path B (trans A B p (transâ»Â¹ A B p b)) b
 := <i> transp (<j> p @ i âˆ¨ j) i (transp (<j> p @ i âˆ¨ -j) i b)

def trans-transâ»Â¹ (A B : U) (p : PathP (<_> U) A B) (a : A) : Path A a (transâ»Â¹ A B p (trans A B p a))
 := <i> transp (<j> p @ i âˆ§ -j) -i (transp (<j> p @ i âˆ§ j) -i a)

def transFill (A B : U) (p : PathP (<_> U) A B) (a : A) : PathP p a (transp p 0 a)
 := <j> transp (<i> p @ i âˆ§ j) -j a

def trans-Î  (A : I -> U) (B : Î  (i : I), A i -> U) (f : Î  (x : A 0), B 0 x) : Î  (x : A 1), B 1 x
 := Î» (x : A 1), transp (<j> B j (transp (<i> A (-i âˆ¨ j)) j x)) 0 (f (transp (<i> A -i) 0 x))

def trans-Î â€² (A : I -> U) (B : Î  (i : I), A i -> U) (f : Î  (x : A 0), B 0 x) : Î  (x : A 1), B 1 x
 := transp (<i> Î  (x : A i), B i x) 0 f

def trans-Î£ (A : I -> U) (B : Î  (i : I), A i -> U) (z : Î£ (x : A 0), B 0 x) : Î£ (x : A 1), B 1 x
 := (transp (<i> A i) 0 z.1, transp (<j> B j (transp (<i> A (i âˆ§ j)) -j z.1)) 0 z.2)

def trans-Î£â€² (A : I -> U) (B : Î  (i : I), A i -> U) (z : Î£ (x : A 0), B 0 x) : Î£ (x : A 1), B 1 x
 := transp (<i> Î£ (x : A i), B i x) 0 z

def trans-Pathâ€² (A B : I â†’ U) (P : Î  (i : I), PathP (<_> U) (A i) (B i)) (v : Î  (i : I), P i @ 0)
    (w : Î  (i : I), P i @ 1) (uâ‚€ : PathP (<i> P 0 @ i) (v 0) (w 0)) : PathP (<i> P 1 @ i) (v 1) (w 1)
 := transp (<i> PathP (P i) (v i) (w i)) 0 uâ‚€

def comp-Pathâ€² (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) : Path A a c
 := transp (<i> Path A a (q @ i)) 0 p

-- Homogeneous Composition

def hcompâ€² (A : U) (r : I) (u : I â†’ Partial A r) (uâ‚€ : A[r â†¦ u 0]) : A := hcomp A r u (ouc uâ‚€)
def hcomp-Îµ (A : U) (a : A) := hcomp A 0 (\(i : I), []) a
def hcomp-Îµâ†’id (A : U) (a : A) : Path A (hcomp-Îµ A a) a := <i> hcomp A i (\(j : I), [(i = 1) â†’ a]) a

def comp-Path (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) : Path A a c
 := <i> hcomp A (âˆ‚ i) (Î» (j : I), [(i = 0) â†’ a, (i = 1) â†’ q @ j]) (p @ i)

def comp-Pathâ»Â¹ (A : U) (a b : A) (p : Path A a b) : Path (Path A a a) (comp-Path A a b a p (<i> p @ -i)) (<_> a)
 := <k j> hcomp A (âˆ‚ j âˆ¨ k) (Î» (i : I), [(j = 0) â†’ a, (j = 1) â†’ p @ -i âˆ§ -k, (k = 1) â†’ a]) (p @ j âˆ§ -k)

def kan (A : U) (a b c d : A) (p : Path A a c) (q : Path A b d) (r : Path A a b) : Path A c d
 := <i> hcomp A (âˆ‚ i) (Î» (j : I), [(i = 0) â†’ p @ j, (i = 1) â†’ q @ j]) (r @ i)

def comp (A : I â†’ U) (r : I) (u : Î  (i : I), Partial (A i) r) (uâ‚€ : (A 0)[r â†¦ u 0]) : A 1
 := hcomp (A 1) r (Î» (i : I), [(r = 1) â†’ transp (<j> A (i âˆ¨ j)) i (u i 1=1)]) (transp (<i> A i) 0 (ouc uâ‚€))

def ghcomp (A : U) (r : I) (u : I â†’ Partial A r) (uâ‚€ : A[r â†¦ u 0]) : A
 := hcomp A (âˆ‚ r) (Î» (j : I), [(r = 1) â†’ u j 1=1, (r = 0) â†’ ouc uâ‚€]) (ouc uâ‚€)

def trans-Path (A B : I â†’ U) (P : Î  (i : I), PathP (<_> U) (A i) (B i)) (v : Î  (i : I), P i @ 0) (w : Î  (i : I), P i @ 1)
    (uâ‚€ : PathP (<i> P 0 @ i) (v 0) (w 0)) : PathP (<i> P 1 @ i) (v 1) (w 1)
 := <j> comp (Î» (i : I), P i @ j) (âˆ‚ j) (Î» (i : I), [(j = 0) â†’ v i, (j = 1) â†’ w i]) (inc (P 0 @ j) (âˆ‚ j) (uâ‚€ @ j))

def hfill (A : U) (r : I) (u : I â†’ Partial A r) (uâ‚€ : A[r â†¦ u 0]) (j : I)
 := hcomp A (-j âˆ¨ r) (Î» (i : I), [(r = 1) â†’ u (i âˆ§ j) 1=1, (j = 0) â†’ ouc uâ‚€]) (ouc uâ‚€)

def hfillâ€² (A : U) (r : I) (u : I â†’ Partial A r) (uâ‚€ : A[r â†¦ u 0]) : Path A (ouc uâ‚€) (hcomp A r u (ouc uâ‚€))
 := <j> hfill A r u uâ‚€ j

def hcomp-Path (A : U) (v w : A) (r : I) (u : I â†’ Partial (Path A v w) r) (uâ‚€ : (Path A v w)[r â†¦ u 0]) : Path A v w
 := <j> hcomp A (r âˆ¨ âˆ‚ j) (Î» (i : I), [(r = 1) â†’ u i 1=1 @ j, (j = 0) â†’ v, (j = 1) â†’ w]) (ouc uâ‚€ @ j)

def hcomp-Pathâ€² (A : U) (v w : A) (r : I) (u : I â†’ Partial (Path A v w) r) (uâ‚€ : (Path A v w)[r â†¦ u 0])
 := hcomp (Path A v w) r u (ouc uâ‚€)

def hcomp-Î  (A : U) (B : A â†’ U) (r : I) (u : I â†’ Partial (Î  (x : A), B x) r) (uâ‚€ : (Î  (x : A), B x)[r â†¦ u 0])
 := Î» (v : A), hcomp (B v) r (Î» (k : I), [(r = 1) â†’ u k 1=1 v]) ((ouc uâ‚€) v)

def hcomp-Î â€² (A : U) (B : A â†’ U) (r : I) (u : I â†’ Partial (Î  (x : A), B x) r) (uâ‚€ : (Î  (x : A), B x)[r â†¦ u 0])
 := hcomp (Î  (x : A), B x) r u (ouc uâ‚€)

def hcomp-Î£ (A : U) (B : A â†’ U) (r : I) (u : I â†’ Partial (Î£ (x : A), B x) r) (uâ‚€ : (Î£ (x : A), B x)[r â†¦ u 0]) : Î£ (x : A), B x
 := (hfill A r (Î» (k : I), [(r = 1) â†’ (u k 1=1).1]) (inc A r (ouc uâ‚€).1) 1,
     comp (Î» (i : I), B (hfill A r (Î» (k : I), [(r = 1) â†’ (u k 1=1).1]) (inc A r (ouc uâ‚€).1) i))
        r (Î» (k : I), [(r = 1) â†’ (u k 1=1).2]) (inc (B (ouc uâ‚€).1) r (ouc uâ‚€).2))

def hcomp-Î£â€² (A : U) (B : A â†’ U) (r : I) (u : I â†’ Partial (Î£ (x : A), B x) r) (uâ‚€ : (Î£ (x : A), B x)[r â†¦ u 0]) : Î£ (x : A), B x
 := hcomp (Î£ (x : A), B x) r u (ouc uâ‚€)

-- Tests

def Pathâ€² (A : U) (a b : A) := Î  (i : I), A [âˆ‚ i â†¦ [(i = 0) â†’ a, (i = 1) â†’ b]]
def Path-Pathâ€² (A : U) (a b : A) (p : Path A a b) : Pathâ€² A a b := Î» (i : I), inc A (âˆ‚ i) (p @ i)
def Pathâ€²-Path (A : U) (a b : A) (p : Pathâ€² A a b) : Path A a b := <i> ouc (p i)
def Path-Pathâ€²-Path (A : U) (a b : A) (p : Path A a b) : Path (Path A a b) (Pathâ€²-Path A a b (Path-Pathâ€² A a b p)) p := <_> p
def Pathâ€²-Path-Pathâ€² (A : U) (a b : A) (p : Pathâ€² A a b) : PathP (<_> Pathâ€² A a b) (Path-Pathâ€² A a b (Pathâ€²-Path A a b p)) p := <_> p

def ğŸ-contr : Î  (x : ğŸ), Path ğŸ x â˜… := indâ‚ (Î» (x : ğŸ), Path ğŸ x â˜…) (<_> â˜…)
