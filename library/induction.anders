module induction where
option girard true

-- Steve Awodey, Nicola Gambino, Kristina Sojakova
-- Inductive Types in Homotopy Type Theory
-- https://arxiv.org/pdf/1201.3898.pdf

def 0-ind (C: empty -> U) (z: empty) : C z := indâ‚€ (C z) z
def 1-ind (C: unit -> U) (x: C star) (z: unit) : C z := indâ‚ C x z
def 2-ind (C: bool -> U) (x: C 0â‚‚) (y: C 1â‚‚) (z: bool) : C z := indâ‚‚ C x y z

def indáµ‚-Î² (A : U) (B : A â†’ U) (C : (W (x : A), B x) â†’ U)
   (g : Î  (x : A) (f : B x â†’ (W (x : A), B x)),
   (Î  (b : B x), C (f b)) â†’ C (sup A B x f))
   (a : A) (f : B a â†’ (W (x : A), B x)) :
   PathP (<_> C (sup A B a f))
         (indáµ‚ A B C g (sup A B a f))
         (g a f (Î» (b : B a), indáµ‚ A B C g (f b)))
 := <_> g a f (Î» (b : B a), indáµ‚ A B C g (f b))

def â„• := W (x : ğŸ), indâ‚‚ (Î» (_ : ğŸ), U) ğŸ ğŸ x
def â„•-ctor := indâ‚‚ (Î» (_ : ğŸ), U) ğŸ ğŸ

def zero : â„• := sup ğŸ â„•-ctor 0â‚‚ (indâ‚€ â„•)
def succ (n : â„•) : â„• := sup ğŸ â„•-ctor 1â‚‚ (Î» (x : ğŸ), n)

def ğŸâ†’â„• (C : â„• â†’ U) (f : ğŸ â†’ â„•) : C zero â†’ C (sup ğŸ â„•-ctor 0â‚‚ f)
 := transp (<i> C (sup ğŸ â„•-ctor 0â‚‚ (Î» (x : ğŸ), indâ‚€ (PathP (<_> â„•) (indâ‚€ â„• x) (f x)) x @ i))) 0

def ğŸâ†’â„• (C : â„• â†’ U) (f : ğŸ â†’ â„•) : C (succ (f â˜…)) â†’ C (sup ğŸ â„•-ctor 1â‚‚ f)
 := transp (<i> C (sup ğŸ â„•-ctor 1â‚‚ (Î» (x : ğŸ), indâ‚ (Î» (y : ğŸ), PathP (<_> â„•) (f â˜…) (f y)) (<_> f â˜…) x @ i))) 0

def â„•-ind (C : â„• â†’ U) (z : C zero) (s : Î  (n : â„•), C n â†’ C (succ n)) : Î  (n : â„•), C n
 := indáµ‚ ğŸ â„•-ctor C
    (indâ‚‚ (Î» (x : ğŸ), Î  (f : â„•-ctor x â†’ â„•), (Î  (b : â„•-ctor x), C (f b)) â†’ C (sup ğŸ â„•-ctor x f))
          (Î» (f : ğŸ â†’ â„•) (g : Î  (x : ğŸ), C (f x)), ğŸâ†’â„• C f z)
          (Î» (f : ğŸ â†’ â„•) (g : Î  (x : ğŸ), C (f x)), ğŸâ†’â„• C f (s (f â˜…) (g â˜…))))

def â„•-rec (C : U) (z : C) (s : â„• â†’ C â†’ C) : â„• â†’ C := â„•-ind (Î» (_ : â„•), C) z s
def â„•-iter (C : U) (z : C) (s : C â†’ C) : â„• â†’ C := â„•-rec C z (Î» (_ : â„•), s)
def â„•-case (C : U) (z s : C) : â„• â†’ C := â„•-iter C z (Î» (_ : C), s)

def + (A B: U) : U := Î£ (x : ğŸ), indâ‚‚ (Î» (_ : ğŸ), U) A B x
def inl (A B : U) (a : A) : + A B := (0â‚‚, a)
def inr (A B : U) (b : B) : + A B := (1â‚‚, b)
def +-ind (A B : U) (C : + A B â†’ U) (f : Î  (x : A), C (inl A B x)) (g : Î  (y : B), C (inr A B y)) (w : + A B) : C w
 := indâ‚‚ (Î» (x : ğŸ), Î  (u : indâ‚‚ (Î» (_ : ğŸ), U) A B x), C (x, u)) f g w.1 w.2

def maybe (A : U) : U := + ğŸ A
def nothing (A : U) : maybe A := (0â‚‚, â˜…)
def just (A : U) (a : A) : maybe A := (1â‚‚, a)
def maybe-ind (A : U) (P: maybe A -> U) (n: P (nothing A)) (j: Î  (x: A), P (just A x)) : Î  (a: maybe A), P a
 := +-ind ğŸ A P (indâ‚ (Î» (x : ğŸ), P (0â‚‚, x)) n) j

def N : U := â„•
def Fin : â„• â†’ U := â„•-iter U ğŸ (+ ğŸ)
def fzero (n : â„•) : Fin (succ n) := (0â‚‚, â˜…)
def fsucc (n : â„•) (m : Fin n) : Fin (succ n) := (1â‚‚, m)
def Fin-ind (T : â„• â†’ U) (m: â„•) (z: Î  (n: â„•), T (succ n)) (s: Î  (n: â„•), T n â†’ T (succ n)) : Fin m â†’ T m
 := ?

def Vec (A: U) : â„• â†’ U := â„•-iter U ğŸ (Î» (X : U), A Ã— X)
def vzero (A: U) : Vec A zero := â˜…
def vsucc (A: U) (n : â„•) (head: A) (tail : Vec A n) : Vec A (succ n) := (head,tail)
def Vec-ind (A: U) (B: â„• â†’ U) (m: â„•) (z: B zero) (s: Î  (n: â„•), A â†’ B n â†’ B (succ n)) : Vec A m â†’ B m
 := ?

def ğŸ‘ : U := Fin (succ (succ (succ zero)))
def 0â‚ƒ : ğŸ‘ := fzero (succ (succ zero))
def 1â‚ƒ : ğŸ‘ := fsucc (succ (succ zero)) (fzero (succ zero))
def 2â‚ƒ : ğŸ‘ := fsucc (succ (succ zero)) (fsucc (succ zero) (fzero zero))

def indâ‚ƒ (C : ğŸ‘ â†’ U) (a : C 0â‚ƒ) (b : C 1â‚ƒ) (c : C 2â‚ƒ) : Î  (x : ğŸ‘), C x
 := +-ind ğŸ (+ ğŸ (+ ğŸ ğŸ)) C (indâ‚ (Î» (x : ğŸ), C (0â‚‚, x)) a)
            (+-ind ğŸ (+ ğŸ ğŸ) (Î» (y : + ğŸ (+ ğŸ ğŸ)), C (1â‚‚, y)) (indâ‚ (Î» (x : ğŸ), C (1â‚‚, (0â‚‚, x))) b)
                     (+-ind ğŸ ğŸ (Î» (x : + ğŸ ğŸ), C (1â‚‚, (1â‚‚, x))) (indâ‚ (Î» (x : ğŸ), C (1â‚‚, (1â‚‚, (0â‚‚, x)))) c)
                              (Î» (y : ğŸ), indâ‚€ (C (1â‚‚, (1â‚‚, (1â‚‚, y)))) y)))