{- MLTT Reality Module Check: https://groupoid.space/articles/mltt/mltt.pdf
   â€” Pi;
   â€” Sigma;
   â€” Path.

   Copyright (c) Groupoid Infinity, 2014-2023. -}

module mltt where
option girard true

def Path (A : U) (x y : A) : U := PathP (<_> A) x y
def idp (A : U) (x : A) : Path A x x := <_> x
def Pi (O : ğŸ) (A : U) (B : A â†’ U) : U := Î  (x : A), B x
def Î -lambda (O : ğŸ) (A: U) (B: A â†’ U) (b: Pi â˜… A B) : Pi â˜… A B := Î» (x : A), b x
def Î -apply (O : ğŸ) (A: U) (B: A â†’ U) (f: Pi â˜… A B) (a: A) : B a := f a
def Î -Î² (O : ğŸ) (A : U) (B : A â†’ U) (a : A) (f : Pi â˜… A B) : Path (B a) (Î -apply â˜… A B (Î -lambda â˜… A B f) a) (f a) := idp (B a) (f a)
def Î -Î· (O : ğŸ) (A : U) (B : A â†’ U) (a : A) (f : Pi â˜… A B) : Path (Pi â˜… A B) f (Î» (x : A), f x) := idp (Pi â˜… A B) f
def Sigma (O : ğŸ) (A : U) (B : A â†’ U) : U := summa (x: A), B x
def pair (O : ğŸ) (A: U) (B: A â†’ U) (a: A) (b: B a) : Sigma â˜… A B := (a, b)
def prâ‚ (O : ğŸ) (A: U) (B: A â†’ U) (x: Sigma â˜… A B) : A := x.1
def prâ‚‚ (O : ğŸ) (A: U) (B: A â†’ U) (x: Sigma â˜… A B) : B (prâ‚ â˜… A B x) := x.2
def Î£-Î²â‚ (O : ğŸ) (A : U) (B : A â†’ U) (a : A) (b : B a) : Path A a (prâ‚ â˜… A B (a ,b)) := idp A a
def Î£-Î²â‚‚ (O : ğŸ) (A : U) (B : A â†’ U) (a : A) (b : B a) : Path (B a) b (prâ‚‚ â˜… A B (a, b)) := idp (B a) b
def Î£-Î· (O : ğŸ) (A : U) (B : A â†’ U) (p : Sigma â˜… A B) : Path (Sigma â˜… A B) p (prâ‚ â˜… A B p, prâ‚‚ â˜… A B p) := idp (Sigma â˜… A B) p

def Path-1 (O : ğŸ) (A : U) (x y : A) : U := PathP (<_> A) x y
def idp-1 (O : ğŸ) (A : U) (x : A) : Path A x x := <_> x
def transport (A B: U) (p : PathP (<_> U) A B) (a: A): B := transp p 0 a
def singl (A: U) (a: A): U := Î£ (x: A), Path A a x
def eta (A: U) (a: A): singl A a := (a, idp A a)
def contr (A : U) (a b : A) (p : Path A a b) : Path (singl A a) (eta A a) (b, p) := <i> (p @ i, <j> p @ i /\ j)
def trans_comp (A : U) (a : A) : Path A a (transport A A (<i> A) a) := <j> transp (<_> A) -j a
def subst (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b := transp (<i> P (p @ i)) 0 e
def subst-comp (A: U) (P: A â†’ U) (a: A) (e: P a): Path (P a) e (subst A P a a (idp A a) e) := trans_comp (P a) e
def D (A : U) : Uâ‚ := Î  (x y : A), Path A x y â†’ U

def J (A: U) (x: A) (C: D A) (d: C x x (idp A x)) (y: A) (p: Path A x y): C x y p
 := subst (singl A x) (\ (z: singl A x), C x (z.1) (z.2)) (eta A x) (y, p) (contr A x y p) d
def J-1 (O : ğŸ) (A : U) (x : A) (C: D A) (d: C x x (idp A x)) (y: A) (p: Path A x y): C x y p
 := subst (singl A x) (\ (z: singl A x), C x (z.1) (z.2)) (eta A x) (y, p) (contr A x y p) d
def J-Î² (O : ğŸ) (A : U) (a : A) (C : D A) (d: C a a (idp A a)) : Path (C a a (idp A a)) d (J A a C d a (idp A a))
 := subst-comp (singl A a) (\ (z: singl A a), C a (z.1) (z.2)) (eta A a) d

def MLTT :=
  Î£ (Î -form  : Î  (A : U) (B : A â†’ U), U)
    (Î -ctorâ‚ : Î  (A : U) (B : A â†’ U), Pi â˜… A B â†’ Pi â˜… A B)
    (Î -elimâ‚ : Î  (A : U) (B : A â†’ U), Pi â˜… A B â†’ Pi â˜… A B)
    (Î -compâ‚ : Î  (A : U) (B : A â†’ U) (a : A) (f : Pi â˜… A B), Path (B a) (Î -elimâ‚ A B (Î -ctorâ‚ A B f) a) (f a))
    (Î -compâ‚‚ : Î  (A : U) (B : A â†’ U) (a : A) (f : Pi â˜… A B), Path (Pi â˜… A B) f (Î» (x : A), f x))
    (Î£-form  : Î  (A : U) (B : A â†’ U), U)
    (Î£-ctorâ‚ : Î  (A : U) (B : A â†’ U) (a : A) (b : B a) , Sigma â˜… A B)
    (Î£-elimâ‚ : Î  (A : U) (B : A â†’ U) (p : Sigma â˜… A B), A)
    (Î£-elimâ‚‚ : Î  (A : U) (B : A â†’ U) (p : Sigma â˜… A B), B (prâ‚ â˜… A B p))
    (Î£-compâ‚ : Î  (A : U) (B : A â†’ U) (a : A) (b: B a), Path A a (Î£-elimâ‚ A B (Î£-ctorâ‚ A B a b)))
    (Î£-compâ‚‚ : Î  (A : U) (B : A â†’ U) (a : A) (b: B a), Path (B a) b (Î£-elimâ‚‚ A B (a, b)))
    (Î£-compâ‚ƒ : Î  (A : U) (B : A â†’ U) (p : Sigma â˜… A B), Path (Sigma â˜… A B) p (prâ‚ â˜… A B p, prâ‚‚ â˜… A B p))
    (=-form  : Î  (A : U) (a : A), A â†’ U)
    (=-ctorâ‚ : Î  (A : U) (a : A), Path A a a)
    (=-elimâ‚ : Î  (A : U) (a : A) (C: D A) (d: C a a (=-ctorâ‚ A a)) (y: A) (p: Path A a y), C a y p)
    (=-compâ‚ : Î  (A : U) (a : A) (C: D A) (d: C a a (=-ctorâ‚ A a)), Path (C a a (=-ctorâ‚ A a)) d (=-elimâ‚ A a C d a (=-ctorâ‚ A a))), ğŸ

--- Self-aware MLTT:
--- Theorem. J-Î²-rule is derivable from generalized transport

def internalizing : MLTT
 := ( Pi â˜…, Î -lambda â˜…, Î -apply â˜…, Î -Î² â˜…, Î -Î· â˜…,
      Sigma â˜…, pair â˜…, prâ‚ â˜…, prâ‚‚ â˜…, Î£-Î²â‚ â˜…, Î£-Î²â‚‚ â˜…, Î£-Î· â˜…,
      Path-1 â˜…, idp-1 â˜…, J-1 â˜…, J-Î² â˜…, â˜…
    )
