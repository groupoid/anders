{- Isomorphisms: https://anders.groupoid.space/foundations/univalent/iso
   - Isomorphism;
   - Unimorphism;
   - Minivalence.

   HoTT 2.4 Homotopies and equivalences

   Copyright (c) Groupoid Infinity, 2014-2023. -}

module iso where
import lib/foundations/univalent/path
import lib/foundations/univalent/equiv

-- Post-Voevodsky CCHM/hcomp lemIso implementation

def fill0 (A B : U) (f : A -> B) (g : B -> A) (x0 x1 : A) (y : B)
    (p0 : Path B (f x0) y) (p1 : Path B (f x1) y)
    (t : Œ† (x : A), Path A (g (f x)) x) (i : I) : I -> A
 := hfill A (‚àÇ i) (Œª (k : I),
      [ (i = 1) ‚Üí t x0 @ k,
        (i = 0) ‚Üí g y ]) (inc A (‚àÇ i) (g (p0 @ -i)))

def fill1 (A B : U) (f : A -> B) (g : B -> A) (x0 x1 : A) (y : B)
    (p0 : Path B (f x0) y) (p1 : Path B (f x1) y)
    (t : Œ† (x : A), Path A (g (f x)) x) (i : I) : I -> A
 := hfill A (‚àÇ i) (Œª (k : I),
      [ (i = 1) ‚Üí t x1 @ k,
        (i = 0) ‚Üí g y ]) (inc A (‚àÇ i) (g (p1 @ -i)))

def fill2 (A B : U) (f : A -> B) (g : B -> A) (x0 x1 : A) (y : B)
    (p0 : Path B (f x0) y) (p1 : Path B (f x1) y)
    (t : Œ† (x : A), Path A (g (f x)) x) (i : I) : I -> A
 := hfill A (‚àÇ i) (Œª (k : I),
      [ (i = 1) ‚Üí fill1 A B f g x0 x1 y p0 p1 t k 1,
        (i = 0) ‚Üí fill0 A B f g x0 x1 y p0 p1 t k 1 ]) (inc A (‚àÇ i) (g y))

def sqA (A B : U) (f : A -> B) (g : B -> A) (x0 x1 : A) (y : B)
    (p0 : Path B (f x0) y) (p1 : Path B (f x1) y)
    (t : Œ† (x : A), Path A (g (f x)) x) (i j : I) : A
 := hcomp A (‚àÇ i ‚à® ‚àÇ j) (Œª (k : I),
      [ (i = 1) ‚Üí fill1 A B f g x0 x1 y p0 p1 t j -k,
        (i = 0) ‚Üí fill0 A B f g x0 x1 y p0 p1 t j -k,
        (j = 1) ‚Üí t (fill2 A B f g x0 x1 y p0 p1 t i 1) @ -k,
        (j = 0) ‚Üí g y ]) (fill2 A B f g x0 x1 y p0 p1 t i j)

def sqB (A B : U) (f : A -> B) (g : B -> A) (x0 x1 : A) (y : B)
    (p0 : Path B (f x0) y) (p1 : Path B (f x1) y)
    (s : Œ† (y : B), Path B (f (g y)) y)
    (t : Œ† (x : A), Path A (g (f x)) x) (i j : I) : B
 := hcomp B (‚àÇ i ‚à® ‚àÇ j) (Œª (k : I),
      [ (i = 1) ‚Üí s (p1 @ -j) @ k,
        (i = 0) ‚Üí s (p0 @ -j) @ k,
        (j = 1) ‚Üí s (f ((<r> fill2 A B f g x0 x1 y p0 p1 t r 1) @ i)) @ k,
        (j = 0) ‚Üí s y @ k ]) (f (sqA A B f g x0 x1 y p0 p1 t i j))

def lemIso (A B : U) (f : A -> B) (g : B -> A)
    (s : Œ† (y : B), Path B (f (g y)) y)
    (t : Œ† (x : A), Path A (g (f x)) x)
    (x0 x1 : A) (y : B) (p0 : Path B y (f x0))
    (p1 : Path B y (f x1))
  : Path (fiber A B f y) (x0, p0) (x1, p1)
 := <i> ((<r> fill2 A B f g x0 x1 y (<k> p0 @ -k) (<k> p1 @ -k) t r 1) @ i,
          <j> sqB   A B f g x0 x1 y (<k> p0 @ -k) (<k> p1 @ -k) s t i j)

-- [Shulman, Lumsdaine, Warren, Licata] 2010

def isoToEquiv (A B : U) (f : A -> B) (g : B -> A)
    (s : Œ† (y : B), Path B (f (g y)) y)
    (t : Œ† (x : A), Path A (g (f x)) x)
  : isEquiv A B f
 := \ (y : B),
      ((g y,<i> s y @ -i),
      \ (z : fiber A B f y),
        lemIso A B f g s t (g y) z.1 y (<i> s y @ -i) z.2)

def isIso (A B: U) (f: A ‚Üí B) : U := Œ£ (g : B ‚Üí A) (s : section A B f g ) (t : retract A B f g ), ùüè
def isBiInv (A B: U) (f: A ‚Üí B) : U := Œ£ (g‚ÇÅ g‚ÇÇ : B ‚Üí A) (s : section A B f g‚ÇÅ) (t : retract A B f g‚ÇÇ), ùüè

def iso (A B: U) : U := Œ£ (f : A ‚Üí B), isIso A B f
def biinv (A B: U) : U := Œ£ (f : A ‚Üí B), isBiInv A B f

-- [Cohen, Coquand, Huber, M√∂rtberg, Joyal] 2016

def iso‚ÜíPath (A B : U) (f : A -> B) (g : B -> A)
    (s : Œ† (y : B), Path B (f (g y)) y)
    (t : Œ† (x : A), Path A (g (f x)) x)
  : PathP (<_> U) A B
 := <i> Glue B (‚àÇ i) [(i = 0) -> (A, f, isoToEquiv A B f g s t),
                      (i = 1) -> (B, id B, idIsEquiv B)]

--- Iso as [Right] Identity System [Sokhatsky]

def iso-intro (A: U) : iso A A := ( id A, id A, (\(x:A), <_>x), (\(x:A), <_>x), ‚òÖ)
def iso-single (B : U) : U := Œ£ (A: U), iso A B
def iso-EquivIsContr (B: U) : isContr (iso-single B) := ?
def iso-isContr‚ÜíisProp (A: U) (w: isContr A) (a b : A) : Path A a b
 := <i> hcomp A (‚àÇ i) (Œª (j : I), [(i = 0) ‚Üí a, (i = 1) ‚Üí (w.2 b) @ j]) ((<i4> w.2 a @ -i) @ i)
def iso-contrSinglEquiv (A B : U) (e : iso A B)
  : Path (iso-single B) (B,iso-intro B) (A,e)
 := isContr‚ÜíisProp (iso-single B) (iso-EquivIsContr B) (B,iso-intro B) (A,e)
def iso-J (A B: U) (P: Œ† (A B: U), iso A B ‚Üí U) (r: P B B (iso-intro B))
  : Œ† (e: iso A B), P A B e
 := Œª (e: iso A B), subst (iso-single B) (\ (z: iso-single B), P z.1 B z.2)
                          (B,iso-intro B) (A,e) (iso-contrSinglEquiv A B e) r

-- Similar to Fibrational Equivalence the notion of Retract/Section based Isomorphism could be introduced
-- as forth-back transport between isomorphism and path equality. This notion is somehow cannonical to all
-- cubical systems and is called Unimorphism here.

-- Unimorphism Type (Iso -> Path)

def uni-Form (A B: U) : U‚ÇÅ := iso A B -> PathP (<_>U) A B
def uni-Intro (A B: U) : uni-Form A B := \ (x : iso A B), iso‚ÜíPath A B x.f x.g x.s x.t
def uni-Elim (A B : U) : PathP (<_> U) A B -> iso A B
 := Œª (p : PathP (<_> U) A B),
      ( coerce A B p,
        coerce B A (<i> p @ -i),
        trans‚Åª¬π-trans A B p, Œª (a : A),
        <k> trans-trans‚Åª¬π A B p a @ -k,
        ‚òÖ
      )

-- The notion of Minivalence as forth-back map between fibrational equivalence
-- and section/retract-based isomorphism is mentioned in Cubical Agda sources.

-- Minivalence Type (Iso -> Equiv)

def mini-Form (A B : U) : U := iso A B -> equiv A B
def mini-Intro (A B : U) : mini-Form A B := \ (x : iso A B), univ-elim A B (iso‚ÜíPath A B x.f x.g x.s x.t)
def mini-Elim (A B : U) : equiv A B -> iso A B := \ (x : equiv A B), ( x.f, inv-equiv A B x, ret-equiv A B x, sec-equiv A B x, star)

