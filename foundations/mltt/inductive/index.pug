include ../../../header

html
    head
        meta(property='og:title'       content='INDUCTIVE')
        meta(property='og:description' content='Inductive Space')
        meta(property='og:url'         content='https://anders.groupoid.space/foundations/mltt/inductive/')

block title
    title INDUCTIVE

block content
    nav
        <a href='../../../index.html'>ANDERS</a>
        <a href='../../../lib/index.html'>LIB</a>
        <a href='#'>INDUCTIVE</a>
    article.main.list
        section
            h1 INDUCTIVE SPACES
            aside
                time Published: 7 OCT 2017
            +tex.
                $ğŸ,$ $ğŸ,$ $ğŸ$ form the inductive base for well-founded
                spaces $\mathrm{W}$ of MLTT-80 that allow to manipulate F-algebras.
                For coinductive streams (G-coalgebras) one may need $\mathrm{M}$
                spaces with reversed intro-elim rules.

            +code.
                def B: U := W (x: + â„• â„•), +-rec â„• â„• (Î» (f: + â„• â„•), U) ğŸ ğŸÃ—ğŸ x
                def L (A: U): U :=    W (x: M A), M-rec A U ğŸ (Î» (a: A), ğŸ) x
                def N: U :=           W (x: ğŸ), indâ‚‚ (Î» (f: ğŸ), U) ğŸ ğŸ x
                def M (A: U): U :=    Î£ (x: ğŸ), indâ‚‚ (Î» (f: ğŸ), U) ğŸ A x
                def + (A B: U): U :=  Î£ (x: ğŸ), indâ‚‚ (Î» (f: ğŸ), U) A B x
                def V (A: Uâ‚):    â„• â†’ U := â„•-iter U ğŸ (Î» (X: U), A Ã— X)
                def F:            â„• â†’ U := â„•-iter U ğŸ (+ ğŸ)
            br.
            +tex.
                For multiple
                occurance of fixpoint variable in W-fiber encoded
                argument use $Ã—$ cartesian product, like for binary trees ğŸ Ã— ğŸ.
                Here is example for List MLTT encoding:
            +code.
                def List (A: U)
                  : Î  (w : M A), U
                 := Î» (w : M A),
                            indâ‚‚ (Î» (x: ğŸ),
                      Î  (u: indâ‚‚ (Î» (x: ğŸ), U) ğŸ A x), U)
                           (indâ‚ (Î» (x: ğŸ), U) ğŸ)
                                 (Î» (a: A), ğŸ) w.1 w.2
            br.

            h1 W
            +tex.
                Well-founded trees without mutual recursion represented as $\mathrm{W}$-types.

            h2 Formation

            +tex.
                $\mathbf{Definition\ 4.1}$ ($\mathrm{W}$-Formation). For $A : \mathcal{U}$ and $B : A \rightarrow \mathcal{U}$, type $\mathrm{W}$
                is defined as $\mathrm{W}(A,B) : \mathcal{U}$ or
            code.
                def W' (A : U) (B : A â†’ U) : U := W (x : A), B x
            +tex(true).
                $$
                    \mathrm{W}_{(x : A)} B(x) : \mathcal{U}.
                $$

            h2 Introduction

            +tex.
                $\mathbf{Definition\ 4.2}$ ($\mathrm{W}$-Introduction). Elements of $\mathrm{W}_{(x : A)} B(x)$ are called
                well-founded trees and created with single $\mathrm{sup}$ constructor:

            code.
                def sup' (A: U) (B: A â†’ U) (x: A) (f: B x â†’ W' A B)
                  : W' A B
                 := sup A B x f

            +tex(true).
                $$
                    \mathrm{sup} : \mathrm{W}_{(x: A)} B(x).
                $$

            h2 Elimination

            +tex.
                $\mathbf{Definition\ 4.3}$ (Induction Principle $\mathrm{ind_W}$). The induction principle states that
                for any types $A: \mathcal{U}$ and $B: A \rightarrow \mathcal{U}$ and type family $C$ over $\mathrm{W}(A,B)$
                and the function $g : G$, where

            +tex(true).
                $$
                   G = \prod_{x: A}\prod_{f: B(x) â†’ \mathrm{W}(A,B)}\prod_{b: B(x)} C(f(b)) â†’ C(\mathrm{sup}(x,f))
                $$
            p.
                there is a dependent function:
            +tex(true).
                $$
                    \mathrm{ind_W} : \prod_{C: \mathrm{W}(A,B) â†’ \mathcal{U}}\prod_{g:G}\prod_{a: A}\prod_{f: B(a) â†’ \mathrm{W}(A,B)}\prod_{b: B(a)}C(f(b)).
                $$

            +code.
                def W-ind (A : U) (B : A â†’ U)
                    (C : (W (x : A), B x) â†’ U)
                    (g : Î  (x : A) (f : B x â†’ (W (x : A), B x)), (Î  (b : B x), C (f b)) â†’ C (sup A B x f))
                    (a : A) (f : B a â†’ (W (x : A), B x)) (b : B a) : C (f b) := indáµ‚ A B C g (f b)
            br.

            h2 Computation
            +tex.
                $\mathbf{Theorem\ 4.4}$ ($\mathrm{ind_W}$ computes). The induction principle $\mathrm{ind^W}$ satisfies
                the equation:
            +tex(true).
                $$
                    \mathrm{ind_W}\mbox{-}\beta : g(a,f,Î»b.\mathrm{ind^W}(g,f(b))) 
                $$
            +tex(true).
                $$
                    =_{def} \mathrm{ind_W}(g,\mathrm{sup}(a,f)).
                $$
            +code.
                def indáµ‚-Î² (A : U) (B : A â†’ U)
                    (C : (W (x : A), B x) â†’ U) (g : Î  (x : A)
                    (f : B x â†’ (W (x : A), B x)), (Î  (b : B x), C (f b)) â†’ C (sup A B x f))
                    (a : A) (f : B a â†’ (W (x : A), B x))
                  : PathP (<_> C (sup A B a f))
                          (indáµ‚ A B C g (sup A B a f))
                          (g a f (Î» (b : B a), indáµ‚ A B C g (f b)))
                 := <_> g a f (Î» (b : B a), indáµ‚ A B C g (f b))
            br.
            h2 Uniqueness

            +tex.
                $\mathbf{Theorem\ 4.5}$ ($W$-Uniqueness).
            +tex(true).
                $$
                    \mathrm{ind_W}\mbox{-}\eta
                $$

            h1 EMPTY
            p.
                The Empty type represents False-type logical ğŸ, type without inhabitants, Void or âŠ¥ (Bottom).
                As it has not inhabitants it lacks both constructors and eliminators, however, it has induction.

            h2 Formation
            +tex.
                $\mathbf{Definition\ 4.6}$ (Empty). Empty-type is defined as built-in ğŸ-type:
            +tex(true).
                $$
                    ğŸ : \mathcal{U}.
                $$

            h2 Elimination
            +tex.
                $\mathbf{Definition\ 4.7}$ (Induction Principle $\mathrm{ind_0}$). ğŸ-type is satisfying the
                induction principle:

            +code.
                def Empty-ind (C: ğŸ â†’ U) (z: ğŸ) : C z := indâ‚€ (C z) z
            +tex(true).
                $$
                    \mathrm{ind_0} : \prod_{C\ :\ ğŸ\ \rightarrow\ \mathcal{U}} \prod_{z\ :\ ğŸ} C(z).
                $$

            +tex.
                $\mathbf{Definition\ 4.7.1}$ (Negation or isEmpty). For any type A negation of A is defined as arrow from A to ğŸ:
            +tex(true).
                $$
                    \neg A := A \rightarrow ğŸ.
                $$

            +code.
                def isEmpty (A: U): U := A â†’ ğŸ

            +tex.
                The witness of $\neg A$ is obtained by assuming A and deriving a contradiction.
                This techniques is called proof of negation and is applicable to any types in constrast
                to proof by contradiction which implies $\neg\neg A \rightarrow A$ (double negation elimination) and is
                applicable only to decidable types with $\neg A + A$ property.
            br

            h1 UNIT

            p.
                Unit type is the simplest type equipped with full set of MLTT inference rules.
                It contains single inhabitant â˜… (star).

            h2 Formation

            +tex.
                $\mathbf{Definition\ 4.8}$ (Unit). Unit-type is defined as built-in ğŸ-type:
            +tex(true).
                $$
                    ğŸ : \mathcal{U}.
                $$

            h2 Introduction

            +tex.
                $\mathbf{Definition\ 4.9}$ (Star). ğŸ-type containts single inhabitant â˜…:
            +tex(true).
                $$
                    â˜… : ğŸ.
                $$

            h2 Elimination

            +tex.
                $\mathbf{Definition\ 4.10}$. (Induction Principle $\mathrm{ind_1}$). ğŸ-type satisfies
                induction principle that for any family $C$ indexed by $x : 1$ there is a function
            +code.
                def 1-ind (C: ğŸ â†’ U) (x: C â˜…) (z: ğŸ) : C z := indâ‚ C x z
            +tex(true).
                $$
                   \mathrm{ind_1} : \prod_{C\ :\ ğŸ\ \rightarrow\ \mathcal{U}} \prod_{x\ :\ C(â˜…)} \prod_{z\ :\ ğŸ} C(z).
                $$

            h2 Computation
            +tex.
                $\mathbf{Theorem\ 4.11}$ (Unit Computes). The following equation holds:
            +tex(true).
                $$
                   \mathrm{ind_1}(x,â˜…) = x.
                $$
            h2 Uniqueness
            +tex.
                $\mathbf{Theorem\ 4.12}$ (Unit Unique).

            h1 BOOL

            +tex.
                ğŸ is a logical boolean type or 0-sphere which has two
                inhabitants false (or $0_2$) and true (or $1_2$).

            h2 Formation

            +tex.
                $\mathbf{Definition\ 4.13}$ (Bool). Boolean-type or 0-sphere is defined as built-in ğŸ-type:
            +tex(true).
                $$
                    ğŸ : \mathcal{U}.
                $$

            h2 Introduction

            +tex.
                $\mathbf{Definition\ 4.14}$ (Bool Constructors $0_2$ and $1_2$).
                $\mathbf{false}$ or $0_2$ and $\mathbf{true}$ or $1_2$.
            +tex(true).
                $$
                    0_ğŸ : ğŸ.
                    1_ğŸ : ğŸ.
                $$

            h2 Elimination

            +tex.
                $\mathbf{Definition\ 4.15}$ (Induction Principle $\mathrm{ind_2}$).
            +code.
                def 2-ind (C: ğŸ â†’ U) (x: C 0â‚‚) (y: C 1â‚‚) (z: ğŸ) : C z := indâ‚‚ C x y z
            +tex(true).
                $$
                   \mathrm{ind_2} : \prod_{C\ :\ ğŸ\ \rightarrow\ U} \prod_{x\ :\ C(0_2)} \prod_{y\ :\ C(0_1)} \prod_{z\ :\ ğŸ} C(z).
                $$
            br


include ../../../footer